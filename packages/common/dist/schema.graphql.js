"use strict";
var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.queryLimits = void 0;
var graphql_tag_1 = __importDefault(require("graphql-tag"));
exports.queryLimits = {
    samples: 500,
    sampleOrganisms: 100,
    projectOrganisms: 100,
    boxStates: 500,
    sites: 500,
    boxes: 500,
    projects: 500,
    taxonomy: 500,
    predictors: 500,
    models: 500,
    sitePredictorValues: 500,
    modelPredictors: 500,
    translations: 500
};
var typeDefs = graphql_tag_1.default(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n    schema {\n        query: Query\n        mutation: Mutation\n    }\n\n    type Query {\n        # Get a project and associated metadata\n        auth: AuthParams\n\n        siteInfo(siteId: Int!): SiteInfo\n\n        \"\"\"\n        this is a string\n        \"\"\"\n        sampleInfo(sampleId: Int!): SampleInfo\n        boxInfo(boxId: Int!): BoxInfo\n        modelInfo(modelId: Int!): ModelInfo\n        samples(limit: Int = ", ", offset: Int = 0): PaginatedSamples\n        sampleOrganisms(\n            limit: Int = ", "\n            offset: Int = 0\n            sampleId: Int\n            boxId: Int\n            siteId: Int\n            sampleYear: Int\n            typeId: Int\n        ): PaginatedSampleOrganisms\n\n        projectOrganisms(projectIds: [Int]!, limit: Int = ", ", offset: Int =0): PaginatedSampleOrganisms\n        sites(limit: Int = ", ", offset: Int = 0, usState: [String]): PaginatedSites\n        # boxStates(limit: Int = ", ", offset: Int = 0): PaginatedBoxStates\n        # individuals(limit: Int, offset: Int): [Individual]\n        boxes(limit: Int = ", ", offset: Int = 0): PaginatedBoxes\n        projects(limit: Int = ", ", offset: Int = 0): PaginatedProjects\n        taxonomy(limit: Int = ", ", offset: Int = 0): PaginatedTaxonomies\n        predictors(modelId: Int, limit: Int = ", ", offset: Int = 0): PaginatedPredictors\n        models(limit: Int = ", ", offset: Int = 0): PaginatedModels\n        sitePredictorValues(siteId: Int!, limit: Int = ", ", offset: Int = 0): PaginatedSitePredictorValues\n        samplePredictorValues(sampleId: Int!): PaginatedSamplePredictorValue\n        modelPredictors(limit: Int = ", ", offset: Int = 0, modelId: Int!): PaginatedModelPredictors\n        translations(limit: Int = ", ", offset: Int = 0): PaginatedTranslations\n\n        # Sample side tables\n        planktonSamples(limit: Int = ", ", offset: Int = 0): PaginatedPlankton\n        driftSamples(limit: Int = ", ", offset: Int = 0): PaginatedDrift\n        fishSamples(limit: Int = ", ", offset: Int = 0): PaginatedFish\n        massSamples(limit: Int = ", ", offset: Int = 0): PaginatedMass\n\n        # Sample Taxonomy\n        sampleTaxaRaw(sampleId: Int!): PaginatedRawSampleTaxa\n        sampleTaxaGeneralized(sampleId: Int!): PaginatedGeneralizedSampleTaxa\n        sampleTaxaTranslation(sampleId: Int!, translationId: Int!): PaginatedSampleTranslationTaxa\n        sampleTaxaRarefied(sampleId: Int!, fixedCount: Int!): PaginatedRarefiedSampleTaxa\n        # sampleTaxaModel(sampleId: Int!, modelId: Int!, limit: Int = ", ", offset: Int = 0): PaginatedSampleTaxa\n    }\n\n    # this schema allows the following mutation:\n    type Mutation {\n        setSitePredictorValue(siteId: Int!, predictorId: Int!, value:String!): Int\n        setSamplePredictorValue(sampleId: Int!, predictorId: Int!, value: String!): Int\n        setSiteCatchment(siteId: Int!, catchment: String!): Int\n        \n    }\n\n    # union PredictorValue = String|Boolean|Int|Float\n\n    type AuthParams {\n        loggedIn: Boolean\n        userPool: String\n        clientId: String\n        region: String\n        domain: String\n    }\n\n    type Sample {\n        sampleId: Int\n        boxId: Int\n        customerName: String\n        boxStateName: String\n        boxStateId: Int\n        submitterName: String\n        siteId: Int\n        siteName: String\n        siteLatitude: Float\n        siteLongitude: Float\n        siteState: String\n        sampleDate: String\n        sampleYear: Int\n        sampleLatitude: Float\n        sampleLongitude: Float\n        sampleType: String\n        sampleMethod: String\n        habitatName: String\n        area: Float\n        fieldSplit: Float\n        labSplit: Float\n        jarCount: Int\n        qualitative: Boolean\n        mesh: Float\n        createdDate: String\n        updatedDate: String\n        qaSampleId: Int\n        diameter: Float\n        subSampleCount: Float\n        towLength: Float\n        volume: Float\n        aliquot: Float\n        siteInterval: Float\n        towType: String\n        netArea: Float\n        netDuration: Float\n        streamDepth: Float\n        netDepth: Float\n        netVelocity: Float\n    }\n\n    type BoxState {\n        boxStateId: Int\n    }\n\n    type Site {\n        siteId: Int\n        siteName: String\n        system: String\n        ecosystem: String\n        longitude: Float\n        latitude: Float\n        usState: String\n        waterbodyType: String\n        waterbodyCode: String\n        waterbodyName: String\n        createdDate: String\n        updatedDate: String\n        hasCatchment: Boolean\n    }\n\n\"\"\"\nDetailed information about a single NAMC site.\n\nThis query includes the point and catchment geometries for the site.\nIt also includes the number of samples available at a particular site.\n\nMore succinct information is available for all sites using the\nsites API endpoint.\n\"\"\"\n    type SiteInfo {\n        \n        \"Unique database generated integer that uniquely identifies each site\"\n        siteId: Int\n\n        \"Unique text identifier for each site\"\n        siteName: String\n        \n        \"The ecological system (e.g. lake, pond, reservoir) in which the site is located.\"\n        system: String\n\n        \"The ecosystem in which the site is located.\"\n        ecosystem: String\n\n        \"GeoJSON point location of the site in [EPSG:4326](https://epsg.io/4326) spatial reference.\"\n        location: String\n\n        \"Longtidue of the site location in decimal degrees.\"\n        longitude: Float\n\n        \"Latitude of the site location in decimal degrees.\"\n        latitude: Float\n\n        \"US State in which the site is located.\"\n        usState: String\n\n        \"\"\"\n        If the site has a waterbody code, then the waterbody type identifies the system that\n        this identifier pertains to. The waterbody type might be NHDPlus 1:100,000 or \n        NHDPlusHR 1:24,000 etc.\n        \"\"\"\n        waterbodyType: String\n\n        \"\"\"\n        The identifier of the waterbody on which this site occurs. Can be null. If a \n        waterbody code exists, then the waterbodyType can be used to determine which\n        system the code belongs to, such as NHDPlus or NHDPlusHR.\n        \"\"\"\n        waterbodyCode: String\n\n        \"The string name of the waterbody on which the site occurs. Typicall this is the stream name.\"\n        waterbodyName: String\n\n        \"The latest date and time that either the site location (point) or catchment (polygon) were changed.\"\n        geometryChanged: String\n\n        \"The system generated date and time that the site record was created in the database.\"\n        createdDate: String\n\n        \"The system generated date and time that the site record was last changed in the database.\"\n        updatedDate: String\n\n        \"GeoJSON polygon of the upstream area that drains into this site in [EPSG:4326](https://epsg.io/4326) spatial reference.\"\n        catchment: String\n\n        \"The number of samples that are available for this site.\"\n        sampleCount: Int\n    }\n\n    type RawSampleTaxa {\n        taxonomyId: Int\n        scientificName: String\n        levelId: Int\n        levelName: String\n        rawCount: Float\n        correctedCount: Float\n        rawBigRareCount: Int\n        correctedBigRareCount: Float\n    }\n\n    type SampleTaxa {\n        taxonomyId: Int\n        scientificName: String\n        taxaLevelId: Int\n        taxaLevel: String\n        organismCount: Int\n    }\n\n    type GeneralizedSampleTaxa {\n        taxonomyId: Int\n        scientificName: String\n        levelId: Int\n        levelName: String\n        lifeStageId: Int\n        lifeStage: String\n        lifeStageAbbreviation: String\n        bugSize: Float\n        rawCount: Float\n        correctedCount: Float\n        rawBigRareCount: Int\n        correctedBigRareCount: Float\n    }\n\n    type TranslationSampleTaxa {  \n        taxonomyId: Int\n        scientificName: String\n        aliasName: String\n        levelId: Int\n        levelName: String\n        rawCount: Float\n        correctedCount: Float\n        rawBigRareCount: Int\n        correctedBigRareCount: Float\n    }\n\n    type RarefiedSampleTaxa {\n        taxonomyId: Int\n        scientificName: String\n        levelId: Int\n        levelName: String\n        organismCount: Int\n    }\n\n    type SampleInfo {\n        sampleId:     Int\n        boxId:        Int\n        customerName:       String\n        customerAbbreviation: String\n        submittedBy:             String\n        boxState:          String\n        siteId:                 Int\n        siteName:               String\n        usState:                  String\n        siteLocation: String\n        siteLongitude: Float\n        siteLatitude: Float\n        visitId:                  String\n        sampleDate:               String\n        sampleTime:               String\n        sampleType:          String\n        sampleMethod:        String\n        habitat:              String\n        sampleLocation: String\n        sampleLongitude: Float\n        sampleLatitude: Float\n        area:                      Float\n        fieldSplit:               Float\n        fieldNotes:               String\n        labSplit:                 Float\n        jarCount:                 Int\n        qualitative:              Boolean\n        labNotes:                String\n        mesh:                    Int\n        createdDate:            String\n        updatedDate:            String\n        sampleDateChanged:       String\n        qaSampleId:            Int\n        metadata:                String\n    }\n\n    type BoxInfo {\n        boxId:                    Int\n                customerId:               Int\n                customerName:         String\n                customerAbbreviation: String\n                submitterId:              Int\n                submittedBy:              String\n                boxStateId:              Int\n                boxState:            String\n                boxReceivedDate:         String\n                processingCompleteDate:  String\n                projectedCompleteDate:   String\n                sampleCount:              Int\n                description:               String\n                metadata:                  String\n                measurements:              Boolean\n                sorterQa:                 Boolean\n                taxaQa:                   Boolean\n                createdDate:              String\n                updatedDate:              String\n    }\n\ntype SamplePredictorValue {\n    predictorId:                 Int\n                abbreviation:                 String\n                calculationScript:           String\n                isTemporal:                  Boolean\n                predictorMetadata:           String\n                predictorValue:              String\n                predictorValueUpdatedDate: String\n                status:                       String\n}\n\ntype PlanktonSample {\n    sampleId:        Int\n    diameter:        Float\n    subSampleCount:  Int\n    towLength:       Float\n    volume:          Float\n    aliquot:         Float\n    sizeInterval:    Float\n    towType:         String\n    updatedDate:     String\n\n}\n\ntype DriftSample {\n    sampleId:    Int\n    netArea:     Float\n    netDuration: Float\n    streamDepth: Float\n    netDepth:    Float\n    netVelocity: Float\n    updatedDate: String\n}\n\ntype FishSample {\n    sampleId: Int\n    taxonomyId: Int\n    scientificName: String\n    levelId: Int\n    levelName: String\n    fishLength: Float\n    fishMass: Float\n    updatedDate: String\n}\n\ntype MassSample {\n    sampleId: Int\n    typeId: Int\n    typeAbbreviation: String\n    typeName: String\n    methodId: Int\n    methodAbbreviation: String\n    methodName: String\n    mass: Float\n    updatedDate: String\n\n}\n\n\n    #  type Individual {\n    #     entityId: Int\n    #     firstName: String\n    #     lastName: String\n    #     initials: String\n    #     affilitationId: Int\n    #     affiliation: String\n    #     email: String\n    #     title: String\n    #     address1: String\n    #     address2: String\n    #     city: String\n    #     stateName: String\n    #     countryName: String\n    #     zipCode: String\n    #     phone: String\n    #     fax: String\n    # }\n\n    type Box {\n        boxId: Int\n        customerId: Int\n        customerName: String\n        submitterId: Int\n        submittedBy: String\n        boxState: String\n        boxReceivedDate: String\n        sampleCount: Int\n        processingCompleteDate: String\n        projectedCompleteDate: String\n    }\n\n    type SampleOrganism {\n        sampleId: Int\n        boxId: Int\n        customerId: Int\n        customerName: String\n        boxStateName: String\n        boxStateId: Int\n        submitterName: String\n        siteId: Int\n        siteName: String\n        siteLatitude: Float\n        siteLongitude: Float\n        siteState: String\n        sampleDate: String\n        sampleLatitude: Float\n        sampleLongitude: Float\n        sampleTime: String\n        typeId: Int\n        sampleType: String\n        methodId: Int\n        sampleMethod: String\n        habitatId: Int\n        habitatName: String\n        area: Float\n        fieldSplit: Float\n        labSplit: Float\n        jarCount: Float\n        qualitative: Boolean\n        mesh: Float\n        createdDate: String\n        updatedDate: String\n        qaSampleId: Int\n        diameter: Float\n        subSampleCount: Float\n        towLength: Float\n        volume: Float\n        aliquot: Float\n        sizeInterval: Float\n        towType: String\n        netArea: Float\n        netDuration: Float\n        streamDepth: Float\n        netDepth: Float\n        netVelocity: Float\n        taxonomyId: Int\n        lifeStage: String\n        bugSize: Float\n        splitCount: Float\n        bigRareCount: Float\n        phylum: String\n        class: String\n        subClass: String\n        order: String\n        family: String\n        genus: String\n        isPrivate: Boolean\n    }\n\n    type Project {\n        projectId: Int\n        projectName: String\n        projectType: String\n        isPrivate: Boolean\n        contactId: Int\n        contactName: String\n        autoUpdateSamples: Boolean\n        description: String\n        sampleCount: Int\n        modelCount: Int\n        createdDate: String\n        updatedDate: String\n    }\n\n    type Taxonomy {\n        taxonomyId: Int\n        phylum: String\n        class: String\n        subclass: String\n        order: String\n        suborder: String\n        family: String\n        subfamily: String\n        tribe: String\n        genus: String\n        subgenus: String\n        species: String\n        subspecies: String\n    }\n\n    type Predictor {\n        predictorId: Int\n        predictorName: String\n        abbreviation: String\n        description: String\n        units: String\n        calculationScript: String\n        predictorTypeId: Int\n        predictorTypeName: String\n        isTemporal: Boolean\n        updatedDate: String\n        createdDate: String\n        modelCount: Int\n    }\n\n    type Model {\n        modelId: Int\n        modelName: String\n        abbreviation: String\n        isActive: Boolean\n        description: String\n        predictorCount: Int\n    }\n\n    type ModelInfo {\n        modelId: Int\n        modelName: String\n        abbreviation: String\n        modelType: String\n        translationId: Int\n        translation: String\n        extentDescription: String\n        platform: String\n        referenceSites: Int\n        groupCount: Int\n        minimumCount: Int\n        oeMean: Float\n        oeStdev: Float\n        taxonomicEffort: String\n        isActive: Boolean\n        fixedCount: Int\n        units: String\n        description: String\n        metadata: String\n        predictorCount: Int\n        createdDate: String\n        updatedDate: String\n        extent: String\n    }\n\n    \"\"\"\n    The value of a non-temporal predictor for a particular site.\n    \"\"\"\n    type SitePredictorValue {\n\n        \"The unique system generated identifier for the predictor.\"\n        predictorId: Int\n\n        \"The unique textual name for the predictor.\"\n        predictorName: String\n\n        \"The unique shorthand abbreviation for the predictor.\"\n        abbreviation: String\n\n        \"Long form information about the predictor.\"\n        description: String\n\n        \"The predictor type (e.g. metrics, atmosphere, geology, anthro).\"\n        predictorType: String\n\n        \"\"\"\n        The predictor value for this site. The value is always a string, even\n        if it represents an integer or floating point value.\n        \"\"\"\n        predictorValue: String\n\n        \"The system generated date and time that the site record was created in the database.\"\n        createdDate: String\n\n        \"The system generated date and time that the site record was last changed in the database.\"\n        updatedDate: String\n\n        \"Optional name of the R function that performs the calculation for this predictor.\"\n        calculationScript: String\n    }\n\n    \"\"\"\n    Information about a model predictor.\n\n    Each predictor can be associated with multiple models. Predictors can also\n    be temporal, in which their values are associated with a particular sample,\n    or they can be non-temporal, in which case their values are associated with\n    sites.\n    \"\"\"\n    type ModelPredictor {\n\n        \"The unique system generated identifier for the predictor.\"\n        predictorId: Int\n\n        \"The unique textual name for the predictor.\"\n        predictorName: String\n\n        \"The unique shorthand abbreviation for the predictor.\"\n        abbreviation: String\n\n        \"The units in which the predictor values are stored.\"\n        units: String\n\n       \"The predictor type (e.g. metrics, atmosphere, geology, anthro).\"\n        predictorType: String\n\n        \"\"\"\n        Boolean representing whether the predictor varies over time or whether\n        there is just a single value for the site. True indicates that the predictor\n        is temporal and values are stored for each sample. False indicates that there\n        is only one predictor value for each site.\n        \"\"\"\n        isTemporal: Boolean\n\n        \"Long form information about the predictor.\"\n        description: String\n\n        \"Miscellaneou structured metadata in GeoJSON format.\"\n        metadata: String\n\n        \"The number of models that use the predictor\"\n        modelCount: Int\n\n        \"The system generated date and time that the site record was created in the database.\"\n        createdDate: String\n\n        \"The system generated date and time that the site record was last changed in the database.\"\n        updatedDate: String\n\n        \"Optional name of the R function that performs the calculation for this predictor.\"\n        calculationScript: String\n\n    }\n\n    type Translation {\n        translationId: Int\n        translationName: String\n        description: String\n        isActive: Boolean\n        taxaCount: Int\n        createdDate: String\n        updatedDate: String\n    }\n\n    # Pagination Types\n    type PaginatedBoxStates {\n        records: [BoxState]\n        nextOffset: Int\n    }\n    type PaginatedModels {\n        records: [Model]\n        nextOffset: Int\n    }\n    type PaginatedSites {\n        records: [Site]\n        nextOffset: Int\n    }\n    type PaginatedSamples {\n        records: [Sample]\n        nextOffset: Int\n    }\n    type PaginatedSampleOrganisms {\n        records: [SampleOrganism]\n        nextOffset: Int\n    }\n    type PaginatedBoxes {\n        records: [Box]\n        nextOffset: Int\n    }\n    type PaginatedProjects {\n        records: [Project]\n        nextOffset: Int\n    }\n    type PaginatedTaxonomies {\n        records: [Taxonomy]\n        nextOffset: Int\n    }\n    type PaginatedPredictors {\n        records: [Predictor]\n        nextOffset: Int\n    }\n    type PaginatedSitePredictorValues {\n        records: [SitePredictorValue]\n        nextOffset: Int\n    }\n\n    type PaginatedSamplePredictorValue {\n        records: [SamplePredictorValue]\n        nextOffset: Int\n    }\n\n    type PaginatedModelPredictors {\n        records: [ModelPredictor]\n        nextOffset: Int\n    }\n\n    type PaginatedTranslations {\n        records: [Translation]\n        nextOffset: Int\n    }\n\n    type PaginatedRawSampleTaxa {\n        records: [RawSampleTaxa]\n        nextOffset: Int\n    }\n\n    type PaginatedSampleTaxa {\n        records: [SampleTaxa]\n        nextOffset: Int\n    }\n\n    type PaginatedGeneralizedSampleTaxa {\n        records: [GeneralizedSampleTaxa]\n        nextOffset: Int\n    }\n\n    type PaginatedSampleTranslationTaxa {\n        records: [TranslationSampleTaxa]\n        nextOffset: Int\n    }\n\n    type PaginatedRarefiedSampleTaxa {\n        records: [RarefiedSampleTaxa]\n        nextOffset: Int\n    }\n\n    type PaginatedPlankton {\n        records: [PlanktonSample]\n        nextOffset: Int\n    }\n\n    type PaginatedDrift {\n        records: [DriftSample]\n        nextOffset: Int\n    }\n\n    type PaginatedFish {\n        records: [FishSample]\n        nextOffset: Int\n    }\n\n    type PaginatedMass {\n        records: [MassSample]\n        nextOffset: Int\n    }\n"], ["\n    schema {\n        query: Query\n        mutation: Mutation\n    }\n\n    type Query {\n        # Get a project and associated metadata\n        auth: AuthParams\n\n        siteInfo(siteId: Int!): SiteInfo\n\n        \"\"\"\n        this is a string\n        \"\"\"\n        sampleInfo(sampleId: Int!): SampleInfo\n        boxInfo(boxId: Int!): BoxInfo\n        modelInfo(modelId: Int!): ModelInfo\n        samples(limit: Int = ", ", offset: Int = 0): PaginatedSamples\n        sampleOrganisms(\n            limit: Int = ", "\n            offset: Int = 0\n            sampleId: Int\n            boxId: Int\n            siteId: Int\n            sampleYear: Int\n            typeId: Int\n        ): PaginatedSampleOrganisms\n\n        projectOrganisms(projectIds: [Int]!, limit: Int = ", ", offset: Int =0): PaginatedSampleOrganisms\n        sites(limit: Int = ", ", offset: Int = 0, usState: [String]): PaginatedSites\n        # boxStates(limit: Int = ", ", offset: Int = 0): PaginatedBoxStates\n        # individuals(limit: Int, offset: Int): [Individual]\n        boxes(limit: Int = ", ", offset: Int = 0): PaginatedBoxes\n        projects(limit: Int = ", ", offset: Int = 0): PaginatedProjects\n        taxonomy(limit: Int = ", ", offset: Int = 0): PaginatedTaxonomies\n        predictors(modelId: Int, limit: Int = ", ", offset: Int = 0): PaginatedPredictors\n        models(limit: Int = ", ", offset: Int = 0): PaginatedModels\n        sitePredictorValues(siteId: Int!, limit: Int = ", ", offset: Int = 0): PaginatedSitePredictorValues\n        samplePredictorValues(sampleId: Int!): PaginatedSamplePredictorValue\n        modelPredictors(limit: Int = ", ", offset: Int = 0, modelId: Int!): PaginatedModelPredictors\n        translations(limit: Int = ", ", offset: Int = 0): PaginatedTranslations\n\n        # Sample side tables\n        planktonSamples(limit: Int = ", ", offset: Int = 0): PaginatedPlankton\n        driftSamples(limit: Int = ", ", offset: Int = 0): PaginatedDrift\n        fishSamples(limit: Int = ", ", offset: Int = 0): PaginatedFish\n        massSamples(limit: Int = ", ", offset: Int = 0): PaginatedMass\n\n        # Sample Taxonomy\n        sampleTaxaRaw(sampleId: Int!): PaginatedRawSampleTaxa\n        sampleTaxaGeneralized(sampleId: Int!): PaginatedGeneralizedSampleTaxa\n        sampleTaxaTranslation(sampleId: Int!, translationId: Int!): PaginatedSampleTranslationTaxa\n        sampleTaxaRarefied(sampleId: Int!, fixedCount: Int!): PaginatedRarefiedSampleTaxa\n        # sampleTaxaModel(sampleId: Int!, modelId: Int!, limit: Int = ", ", offset: Int = 0): PaginatedSampleTaxa\n    }\n\n    # this schema allows the following mutation:\n    type Mutation {\n        setSitePredictorValue(siteId: Int!, predictorId: Int!, value:String!): Int\n        setSamplePredictorValue(sampleId: Int!, predictorId: Int!, value: String!): Int\n        setSiteCatchment(siteId: Int!, catchment: String!): Int\n        \n    }\n\n    # union PredictorValue = String|Boolean|Int|Float\n\n    type AuthParams {\n        loggedIn: Boolean\n        userPool: String\n        clientId: String\n        region: String\n        domain: String\n    }\n\n    type Sample {\n        sampleId: Int\n        boxId: Int\n        customerName: String\n        boxStateName: String\n        boxStateId: Int\n        submitterName: String\n        siteId: Int\n        siteName: String\n        siteLatitude: Float\n        siteLongitude: Float\n        siteState: String\n        sampleDate: String\n        sampleYear: Int\n        sampleLatitude: Float\n        sampleLongitude: Float\n        sampleType: String\n        sampleMethod: String\n        habitatName: String\n        area: Float\n        fieldSplit: Float\n        labSplit: Float\n        jarCount: Int\n        qualitative: Boolean\n        mesh: Float\n        createdDate: String\n        updatedDate: String\n        qaSampleId: Int\n        diameter: Float\n        subSampleCount: Float\n        towLength: Float\n        volume: Float\n        aliquot: Float\n        siteInterval: Float\n        towType: String\n        netArea: Float\n        netDuration: Float\n        streamDepth: Float\n        netDepth: Float\n        netVelocity: Float\n    }\n\n    type BoxState {\n        boxStateId: Int\n    }\n\n    type Site {\n        siteId: Int\n        siteName: String\n        system: String\n        ecosystem: String\n        longitude: Float\n        latitude: Float\n        usState: String\n        waterbodyType: String\n        waterbodyCode: String\n        waterbodyName: String\n        createdDate: String\n        updatedDate: String\n        hasCatchment: Boolean\n    }\n\n\"\"\"\nDetailed information about a single NAMC site.\n\nThis query includes the point and catchment geometries for the site.\nIt also includes the number of samples available at a particular site.\n\nMore succinct information is available for all sites using the\nsites API endpoint.\n\"\"\"\n    type SiteInfo {\n        \n        \"Unique database generated integer that uniquely identifies each site\"\n        siteId: Int\n\n        \"Unique text identifier for each site\"\n        siteName: String\n        \n        \"The ecological system (e.g. lake, pond, reservoir) in which the site is located.\"\n        system: String\n\n        \"The ecosystem in which the site is located.\"\n        ecosystem: String\n\n        \"GeoJSON point location of the site in [EPSG:4326](https://epsg.io/4326) spatial reference.\"\n        location: String\n\n        \"Longtidue of the site location in decimal degrees.\"\n        longitude: Float\n\n        \"Latitude of the site location in decimal degrees.\"\n        latitude: Float\n\n        \"US State in which the site is located.\"\n        usState: String\n\n        \"\"\"\n        If the site has a waterbody code, then the waterbody type identifies the system that\n        this identifier pertains to. The waterbody type might be NHDPlus 1:100,000 or \n        NHDPlusHR 1:24,000 etc.\n        \"\"\"\n        waterbodyType: String\n\n        \"\"\"\n        The identifier of the waterbody on which this site occurs. Can be null. If a \n        waterbody code exists, then the waterbodyType can be used to determine which\n        system the code belongs to, such as NHDPlus or NHDPlusHR.\n        \"\"\"\n        waterbodyCode: String\n\n        \"The string name of the waterbody on which the site occurs. Typicall this is the stream name.\"\n        waterbodyName: String\n\n        \"The latest date and time that either the site location (point) or catchment (polygon) were changed.\"\n        geometryChanged: String\n\n        \"The system generated date and time that the site record was created in the database.\"\n        createdDate: String\n\n        \"The system generated date and time that the site record was last changed in the database.\"\n        updatedDate: String\n\n        \"GeoJSON polygon of the upstream area that drains into this site in [EPSG:4326](https://epsg.io/4326) spatial reference.\"\n        catchment: String\n\n        \"The number of samples that are available for this site.\"\n        sampleCount: Int\n    }\n\n    type RawSampleTaxa {\n        taxonomyId: Int\n        scientificName: String\n        levelId: Int\n        levelName: String\n        rawCount: Float\n        correctedCount: Float\n        rawBigRareCount: Int\n        correctedBigRareCount: Float\n    }\n\n    type SampleTaxa {\n        taxonomyId: Int\n        scientificName: String\n        taxaLevelId: Int\n        taxaLevel: String\n        organismCount: Int\n    }\n\n    type GeneralizedSampleTaxa {\n        taxonomyId: Int\n        scientificName: String\n        levelId: Int\n        levelName: String\n        lifeStageId: Int\n        lifeStage: String\n        lifeStageAbbreviation: String\n        bugSize: Float\n        rawCount: Float\n        correctedCount: Float\n        rawBigRareCount: Int\n        correctedBigRareCount: Float\n    }\n\n    type TranslationSampleTaxa {  \n        taxonomyId: Int\n        scientificName: String\n        aliasName: String\n        levelId: Int\n        levelName: String\n        rawCount: Float\n        correctedCount: Float\n        rawBigRareCount: Int\n        correctedBigRareCount: Float\n    }\n\n    type RarefiedSampleTaxa {\n        taxonomyId: Int\n        scientificName: String\n        levelId: Int\n        levelName: String\n        organismCount: Int\n    }\n\n    type SampleInfo {\n        sampleId:     Int\n        boxId:        Int\n        customerName:       String\n        customerAbbreviation: String\n        submittedBy:             String\n        boxState:          String\n        siteId:                 Int\n        siteName:               String\n        usState:                  String\n        siteLocation: String\n        siteLongitude: Float\n        siteLatitude: Float\n        visitId:                  String\n        sampleDate:               String\n        sampleTime:               String\n        sampleType:          String\n        sampleMethod:        String\n        habitat:              String\n        sampleLocation: String\n        sampleLongitude: Float\n        sampleLatitude: Float\n        area:                      Float\n        fieldSplit:               Float\n        fieldNotes:               String\n        labSplit:                 Float\n        jarCount:                 Int\n        qualitative:              Boolean\n        labNotes:                String\n        mesh:                    Int\n        createdDate:            String\n        updatedDate:            String\n        sampleDateChanged:       String\n        qaSampleId:            Int\n        metadata:                String\n    }\n\n    type BoxInfo {\n        boxId:                    Int\n                customerId:               Int\n                customerName:         String\n                customerAbbreviation: String\n                submitterId:              Int\n                submittedBy:              String\n                boxStateId:              Int\n                boxState:            String\n                boxReceivedDate:         String\n                processingCompleteDate:  String\n                projectedCompleteDate:   String\n                sampleCount:              Int\n                description:               String\n                metadata:                  String\n                measurements:              Boolean\n                sorterQa:                 Boolean\n                taxaQa:                   Boolean\n                createdDate:              String\n                updatedDate:              String\n    }\n\ntype SamplePredictorValue {\n    predictorId:                 Int\n                abbreviation:                 String\n                calculationScript:           String\n                isTemporal:                  Boolean\n                predictorMetadata:           String\n                predictorValue:              String\n                predictorValueUpdatedDate: String\n                status:                       String\n}\n\ntype PlanktonSample {\n    sampleId:        Int\n    diameter:        Float\n    subSampleCount:  Int\n    towLength:       Float\n    volume:          Float\n    aliquot:         Float\n    sizeInterval:    Float\n    towType:         String\n    updatedDate:     String\n\n}\n\ntype DriftSample {\n    sampleId:    Int\n    netArea:     Float\n    netDuration: Float\n    streamDepth: Float\n    netDepth:    Float\n    netVelocity: Float\n    updatedDate: String\n}\n\ntype FishSample {\n    sampleId: Int\n    taxonomyId: Int\n    scientificName: String\n    levelId: Int\n    levelName: String\n    fishLength: Float\n    fishMass: Float\n    updatedDate: String\n}\n\ntype MassSample {\n    sampleId: Int\n    typeId: Int\n    typeAbbreviation: String\n    typeName: String\n    methodId: Int\n    methodAbbreviation: String\n    methodName: String\n    mass: Float\n    updatedDate: String\n\n}\n\n\n    #  type Individual {\n    #     entityId: Int\n    #     firstName: String\n    #     lastName: String\n    #     initials: String\n    #     affilitationId: Int\n    #     affiliation: String\n    #     email: String\n    #     title: String\n    #     address1: String\n    #     address2: String\n    #     city: String\n    #     stateName: String\n    #     countryName: String\n    #     zipCode: String\n    #     phone: String\n    #     fax: String\n    # }\n\n    type Box {\n        boxId: Int\n        customerId: Int\n        customerName: String\n        submitterId: Int\n        submittedBy: String\n        boxState: String\n        boxReceivedDate: String\n        sampleCount: Int\n        processingCompleteDate: String\n        projectedCompleteDate: String\n    }\n\n    type SampleOrganism {\n        sampleId: Int\n        boxId: Int\n        customerId: Int\n        customerName: String\n        boxStateName: String\n        boxStateId: Int\n        submitterName: String\n        siteId: Int\n        siteName: String\n        siteLatitude: Float\n        siteLongitude: Float\n        siteState: String\n        sampleDate: String\n        sampleLatitude: Float\n        sampleLongitude: Float\n        sampleTime: String\n        typeId: Int\n        sampleType: String\n        methodId: Int\n        sampleMethod: String\n        habitatId: Int\n        habitatName: String\n        area: Float\n        fieldSplit: Float\n        labSplit: Float\n        jarCount: Float\n        qualitative: Boolean\n        mesh: Float\n        createdDate: String\n        updatedDate: String\n        qaSampleId: Int\n        diameter: Float\n        subSampleCount: Float\n        towLength: Float\n        volume: Float\n        aliquot: Float\n        sizeInterval: Float\n        towType: String\n        netArea: Float\n        netDuration: Float\n        streamDepth: Float\n        netDepth: Float\n        netVelocity: Float\n        taxonomyId: Int\n        lifeStage: String\n        bugSize: Float\n        splitCount: Float\n        bigRareCount: Float\n        phylum: String\n        class: String\n        subClass: String\n        order: String\n        family: String\n        genus: String\n        isPrivate: Boolean\n    }\n\n    type Project {\n        projectId: Int\n        projectName: String\n        projectType: String\n        isPrivate: Boolean\n        contactId: Int\n        contactName: String\n        autoUpdateSamples: Boolean\n        description: String\n        sampleCount: Int\n        modelCount: Int\n        createdDate: String\n        updatedDate: String\n    }\n\n    type Taxonomy {\n        taxonomyId: Int\n        phylum: String\n        class: String\n        subclass: String\n        order: String\n        suborder: String\n        family: String\n        subfamily: String\n        tribe: String\n        genus: String\n        subgenus: String\n        species: String\n        subspecies: String\n    }\n\n    type Predictor {\n        predictorId: Int\n        predictorName: String\n        abbreviation: String\n        description: String\n        units: String\n        calculationScript: String\n        predictorTypeId: Int\n        predictorTypeName: String\n        isTemporal: Boolean\n        updatedDate: String\n        createdDate: String\n        modelCount: Int\n    }\n\n    type Model {\n        modelId: Int\n        modelName: String\n        abbreviation: String\n        isActive: Boolean\n        description: String\n        predictorCount: Int\n    }\n\n    type ModelInfo {\n        modelId: Int\n        modelName: String\n        abbreviation: String\n        modelType: String\n        translationId: Int\n        translation: String\n        extentDescription: String\n        platform: String\n        referenceSites: Int\n        groupCount: Int\n        minimumCount: Int\n        oeMean: Float\n        oeStdev: Float\n        taxonomicEffort: String\n        isActive: Boolean\n        fixedCount: Int\n        units: String\n        description: String\n        metadata: String\n        predictorCount: Int\n        createdDate: String\n        updatedDate: String\n        extent: String\n    }\n\n    \"\"\"\n    The value of a non-temporal predictor for a particular site.\n    \"\"\"\n    type SitePredictorValue {\n\n        \"The unique system generated identifier for the predictor.\"\n        predictorId: Int\n\n        \"The unique textual name for the predictor.\"\n        predictorName: String\n\n        \"The unique shorthand abbreviation for the predictor.\"\n        abbreviation: String\n\n        \"Long form information about the predictor.\"\n        description: String\n\n        \"The predictor type (e.g. metrics, atmosphere, geology, anthro).\"\n        predictorType: String\n\n        \"\"\"\n        The predictor value for this site. The value is always a string, even\n        if it represents an integer or floating point value.\n        \"\"\"\n        predictorValue: String\n\n        \"The system generated date and time that the site record was created in the database.\"\n        createdDate: String\n\n        \"The system generated date and time that the site record was last changed in the database.\"\n        updatedDate: String\n\n        \"Optional name of the R function that performs the calculation for this predictor.\"\n        calculationScript: String\n    }\n\n    \"\"\"\n    Information about a model predictor.\n\n    Each predictor can be associated with multiple models. Predictors can also\n    be temporal, in which their values are associated with a particular sample,\n    or they can be non-temporal, in which case their values are associated with\n    sites.\n    \"\"\"\n    type ModelPredictor {\n\n        \"The unique system generated identifier for the predictor.\"\n        predictorId: Int\n\n        \"The unique textual name for the predictor.\"\n        predictorName: String\n\n        \"The unique shorthand abbreviation for the predictor.\"\n        abbreviation: String\n\n        \"The units in which the predictor values are stored.\"\n        units: String\n\n       \"The predictor type (e.g. metrics, atmosphere, geology, anthro).\"\n        predictorType: String\n\n        \"\"\"\n        Boolean representing whether the predictor varies over time or whether\n        there is just a single value for the site. True indicates that the predictor\n        is temporal and values are stored for each sample. False indicates that there\n        is only one predictor value for each site.\n        \"\"\"\n        isTemporal: Boolean\n\n        \"Long form information about the predictor.\"\n        description: String\n\n        \"Miscellaneou structured metadata in GeoJSON format.\"\n        metadata: String\n\n        \"The number of models that use the predictor\"\n        modelCount: Int\n\n        \"The system generated date and time that the site record was created in the database.\"\n        createdDate: String\n\n        \"The system generated date and time that the site record was last changed in the database.\"\n        updatedDate: String\n\n        \"Optional name of the R function that performs the calculation for this predictor.\"\n        calculationScript: String\n\n    }\n\n    type Translation {\n        translationId: Int\n        translationName: String\n        description: String\n        isActive: Boolean\n        taxaCount: Int\n        createdDate: String\n        updatedDate: String\n    }\n\n    # Pagination Types\n    type PaginatedBoxStates {\n        records: [BoxState]\n        nextOffset: Int\n    }\n    type PaginatedModels {\n        records: [Model]\n        nextOffset: Int\n    }\n    type PaginatedSites {\n        records: [Site]\n        nextOffset: Int\n    }\n    type PaginatedSamples {\n        records: [Sample]\n        nextOffset: Int\n    }\n    type PaginatedSampleOrganisms {\n        records: [SampleOrganism]\n        nextOffset: Int\n    }\n    type PaginatedBoxes {\n        records: [Box]\n        nextOffset: Int\n    }\n    type PaginatedProjects {\n        records: [Project]\n        nextOffset: Int\n    }\n    type PaginatedTaxonomies {\n        records: [Taxonomy]\n        nextOffset: Int\n    }\n    type PaginatedPredictors {\n        records: [Predictor]\n        nextOffset: Int\n    }\n    type PaginatedSitePredictorValues {\n        records: [SitePredictorValue]\n        nextOffset: Int\n    }\n\n    type PaginatedSamplePredictorValue {\n        records: [SamplePredictorValue]\n        nextOffset: Int\n    }\n\n    type PaginatedModelPredictors {\n        records: [ModelPredictor]\n        nextOffset: Int\n    }\n\n    type PaginatedTranslations {\n        records: [Translation]\n        nextOffset: Int\n    }\n\n    type PaginatedRawSampleTaxa {\n        records: [RawSampleTaxa]\n        nextOffset: Int\n    }\n\n    type PaginatedSampleTaxa {\n        records: [SampleTaxa]\n        nextOffset: Int\n    }\n\n    type PaginatedGeneralizedSampleTaxa {\n        records: [GeneralizedSampleTaxa]\n        nextOffset: Int\n    }\n\n    type PaginatedSampleTranslationTaxa {\n        records: [TranslationSampleTaxa]\n        nextOffset: Int\n    }\n\n    type PaginatedRarefiedSampleTaxa {\n        records: [RarefiedSampleTaxa]\n        nextOffset: Int\n    }\n\n    type PaginatedPlankton {\n        records: [PlanktonSample]\n        nextOffset: Int\n    }\n\n    type PaginatedDrift {\n        records: [DriftSample]\n        nextOffset: Int\n    }\n\n    type PaginatedFish {\n        records: [FishSample]\n        nextOffset: Int\n    }\n\n    type PaginatedMass {\n        records: [MassSample]\n        nextOffset: Int\n    }\n"])), exports.queryLimits.samples, exports.queryLimits.sampleOrganisms, exports.queryLimits.projectOrganisms, exports.queryLimits.sites, exports.queryLimits.boxStates, exports.queryLimits.boxes, exports.queryLimits.projects, exports.queryLimits.taxonomy, exports.queryLimits.predictors, exports.queryLimits.models, exports.queryLimits.sitePredictorValues, exports.queryLimits.modelPredictors, exports.queryLimits.translations, exports.queryLimits.samples, exports.queryLimits.samples, exports.queryLimits.samples, exports.queryLimits.samples, exports.queryLimits.translations);
exports.default = typeDefs;
var templateObject_1;
//# sourceMappingURL=schema.graphql.js.map