CREATE EXTENSION postgis;
CREATE EXTENSION tablefunc;


/******************************************************************************************************************
 GEO SCHEMA
 */

CREATE SCHEMA geo;
GRANT USAGE ON SCHEMA geo TO PUBLIC;

CREATE TABLE geo.countries (
    country_id          SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    country_name        VARCHAR(50) UNIQUE NOT NULL,
    abbreviation        VARCHAR(5) NOT NULL,
    geom                GEOMETRY(MultiPolygon, 4326),
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE INDEX gx_countries_geom ON geo.countries USING GIST(geom);

CREATE TABLE geo.states (
    state_id            SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    country_id          SMALLINT NOT NULL,
    state_name          VARCHAR(50) NOT NULL,
    abbreviation        VARCHAR(2) NOT NULL,
    geom                GEOMETRY(MultiPolygon, 4326),
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_states_country_id FOREIGN KEY (country_id) REFERENCES geo.countries(country_id)
);
CREATE INDEX ix_states_country_id ON geo.states(country_id);
CREATE UNIQUE INDEX ux_states_name ON geo.states(country_id, state_name);
CREATE UNIQUE INDEX ux_states_abbreviation ON geo.states(country_id, abbreviation);
CREATE INDEX gx_states_geom ON geo.states USING GIST(geom);

CREATE TABLE geo.counties (
    county_id           SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    state_id            SMALLINT NOT NULL,
    county_name         VARCHAR(255) NOT NULL,
    geom                GEOMETRY(MultiPolygon, 4326),
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_counties_state_id FOREIGN KEY (state_id) REFERENCES geo.states(state_id)
);
CREATE INDEX ix_counties_state_id ON geo.counties(state_id);
CREATE UNIQUE INDEX ux_counties_name ON geo.counties(state_id, county_name);
CREATE INDEX gx_counties_geom ON geo.counties USING GIST(geom);


CREATE TABLE geo.land_uses (
    land_use_id         SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    land_use_name       VARCHAR(50) UNIQUE NOT NULL,
    is_active          BOOLEAN NOT NULL DEFAULT TRUE,
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE geo.ecosystems (
    ecosystem_id        SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    ecosystem_name      VARCHAR(10) UNIQUE NOT NULL,
    is_active          BOOLEAN NOT NULL DEFAULT TRUE,
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE geo.habitats (
    habitat_id          SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    habitat_name        VARCHAR(50) UNIQUE NOT NULL,
    ecosystem_id        SMALLINT NOT NULL,
    is_active          BOOLEAN NOT NULL DEFAULT TRUE,
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_habitats_ecosystem_id FOREIGN KEY (ecosystem_id) REFERENCES geo.ecosystems(ecosystem_id)
);
CREATE INDEX ix_habitats_ecosystem_id ON geo.habitats(ecosystem_id);

CREATE TABLE geo.units (
    unit_id             SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    unit_name           VARCHAR(50) UNIQUE NOT NULL,
    abbreviation        VARCHAR(10) UNIQUE NOT NULL,
    description         TEXT,
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE geo.systems (
    system_id           SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    system_name         VARCHAR(20) UNIQUE NOT NULL,
    ecosystem_id        SMALLINT NOT NULL,
    is_active          BOOLEAN NOT NULL DEFAULT TRUE,
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_systems_ecosystem_id FOREIGN KEY (ecosystem_id) REFERENCES geo.ecosystems(ecosystem_id)
);
CREATE INDEX ix_systems_ecosystem_id ON geo.systems(ecosystem_id);

-- TODO: table design incomplete
CREATE TABLE geo.sites (
    site_id             SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    site_name           VARCHAR(50) UNIQUE NOT NULL,
    system_id           SMALLINT,
    ecosystem_id        SMALLINT,
    description         TEXT,
    waterbody           VARCHAR(255),
    location            GEOMETRY(Point, 4326) NOT NULL,
    catchment           GEOMETRY(MultiPolygon, 4326),
    NHDPlusID           BIGINT,
    COMID               BIGINT,
    metadata            JSON,
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_sites_system_id FOREIGN KEY (system_id) REFERENCES geo.systems(system_id),
    CONSTRAINT fk_sites_ecosystem_id FOREIGN KEY (ecosystem_id) REFERENCES geo.ecosystems(ecosystem_id)
);
CREATE INDEX gx_sites_location ON geo.sites USING GIST(location);
CREATE INDEX gx_sites_catchment ON geo.sites USING GIST(catchment);
CREATE INDEX fx_sites_systems ON geo.sites(system_id);
CREATE INDEX fx_sites_ecosystems ON geo.sites(ecosystem_id);

CREATE TABLE geo.indicator_types (
    indicator_type_id   SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    indicator_type_name VARCHAR(255) UNIQUE NOT NULL,
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE geo.indicators (
    indicator_id        SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    indicator_name      VARCHAR(255) UNIQUE NOT NULL,
    abbreviation        VARCHAR(25) UNIQUE NOT NULL,
    unit_id             SMALLINT NOT NULL,
    description         TEXT,
    metadata            JSON,
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_indicators_unit_id FOREIGN KEY (unit_id) REFERENCES geo.units(unit_id)
);
CREATE INDEX fx_indicators_unit_id ON geo.indicators(unit_id);

CREATE TABLE geo.site_indicators (
    indicator_id        SMALLINT NOT NULL,
    site_id             SMALLINT NOT NULL,
    metadata            JSONB NOT NULL,
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT pk_site_indicators PRIMARY KEY (indicator_id, site_id),
    CONSTRAINT fk_site_indicators FOREIGN KEY (indicator_id) REFERENCES geo.indicators(indicator_id),
    CONSTRAINT fk_site_site_id FOREIGN KEY (site_id) REFERENCES geo.sites(site_id)
);

/******************************************************************************************************************
 ENTITY SCHEMA
 */

CREATE SCHEMA entity;
GRANT USAGE ON SCHEMA entity TO PUBLIC;
-- ALTER DEFAULT PRIVILEGES IN SCHEMA entity GRANT ALL ON TABLES TO PUBLIC;

CREATE TABLE entity.entities (
    entity_id           SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    parent_id           SMALLINT,
    address1            VARCHAR(255),
    address2            VARCHAR(255),
    city                VARCHAR(255),
    state_id            SMALLINT,
    country_id          SMALLINT NOT NULL,
    zip_code            VARCHAR(20),
    phone               VARCHAR(50),
    fax                 VARCHAR(50),
    website             VARCHAR(255),
    notes               TEXT,
    metadata            JSON,
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_entities_parent_id FOREIGN KEY (parent_id) REFERENCES entity.entities(entity_id),
    CONSTRAINT fk_entities_state_id FOREIGN KEY (state_id) REFERENCES geo.states(state_id),
    CONSTRAINT fk_entities_country_id FOREIGN KEY (country_id) REFERENCES geo.countries(country_id)
);
CREATE INDEX fx_entities_state_id ON entity.entities(state_id);
CREATE INDEX fx_entities_country_id ON entity.entities(country_id);

CREATE TABLE entity.organization_types (
    organization_type_id    SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    organization_type_name  VARCHAR(50) UNIQUE NOT NULL
);

CREATE TABLE entity.organizations (
    organization_id         SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    abbreviation            VARCHAR(50),
    organization_name       VARCHAR(255),
    entity_id               SMALLINT NOT NULL,
    organization_type_id    SMALLINT NOT NULL,
    is_lab                  BOOLEAN NOT NULL DEFAULT FALSE,

    CONSTRAINT fk_organizations_entity_id FOREIGN KEY (entity_id) REFERENCES entity.entities(entity_id),
    CONSTRAINT fk_organizations_organization_type_id FOREIGN KEY (organization_type_id) REFERENCES entity.organization_types(organization_type_id)
);
CREATE UNIQUE INDEX ux_organizations_entity_id ON entity.organizations(entity_id);
CREATE INDEX fx_organizations_organization_type_id ON entity.organizations(organization_type_id);

-- TODO: table design incomplete. Need to implement roles here.
-- TODO: do we really need gender and other non-bug identification information
CREATE TABLE entity.individuals (
    individual_id       SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    first_name          VARCHAR(50) NOT NULL,
    last_name           VARCHAR(50) NOT NULL,
    initials            VARCHAR(3),
    entity_id           SMALLINT NOT NULL,
    affiliation_id      SMALLINT,
    email               VARCHAR(255),

    CONSTRAINT fk_individuals_entity_id FOREIGN KEY (entity_id) REFERENCES entity.entities(entity_id),
    CONSTRAINT fk_individuals_affiliation_id FOREIGN KEY (affiliation_id) REFERENCES entity.organizations(organization_id)
);
CREATE UNIQUE INDEX ux_individuals_entity_id ON entity.individuals(entity_id);
CREATE INDEX fx_individuals_affiliation_id ON entity.individuals(affiliation_id);

CREATE TABLE entity.roles (
    role_id             SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    role_name           VARCHAR(255) UNIQUE NOT NULL,
    description         TEXT
);

CREATE TABLE entity.individual_roles (
    individual_id       SMALLINT NOT NULL,
    role_id             SMALLINT NOT NULL,

    CONSTRAINT pk_individuals_roles PRIMARY KEY (individual_id, role_id),
    CONSTRAINT fk_individual_roles_individual_id FOREIGN KEY (individual_id) REFERENCES entity.individuals(individual_id),
    CONSTRAINT fk_individual_roles_role_id FOREIGN KEY (role_id) REFERENCES entity.roles(role_id)
);

CREATE TABLE entity.lab_types (
    lab_type_id         SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    lab_type_name       VARCHAR(255) UNIQUE NOT NULL
);

-- -- TODO: table design incomplete
-- CREATE TABLE predictors (
--     predictor_id        SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
--     predictor_name      VARCHAR(50) UNIQUE NOT NULL,
--     notes               TEXT,
--     unit_id             SMALLINT NOT NULL,
--     created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
--     updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
--
--     CONSTRAINT fk_predictors_unit_id FOREIGN KEY (unit_id) REFERENCES units(unit_id)
-- );
-- CREATE INDEX ix_predictors_unit_id ON predictors(unit_id);
--
-- -- TODO: table design incomplete
-- CREATE TABLE model_types (
--     model_type_id       SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
--     model_type_name     VARCHAR(50) UNIQUE NOT NULL,
--     created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
--     updated_date        TIMESTAMPTZ NOT NULL DEFAULT now()
-- );
--
-- -- TODO: table design incomplete
-- -- TODO: determine if state_id can be NOT NULL. Allowing NULL might enable national level models.
-- CREATE TABLE models (
--     model_id            SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
--     model_name          VARCHAR(255) UNIQUE NOT NULL,
--     model_type_id       SMALLINT NOT NULL,
--     state_id            SMALLINT NOT NULL,
--     is_active           BOOLEAN NOT NULL DEFAULT TRUE,
--     notes               TEXT,
--     created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
--     updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
--
--     CONSTRAINT fk_models_model_type_id FOREIGN KEY (model_type_id) REFERENCES model_types(model_type_id),
--     CONSTRAINT fk_models_state_id FOREIGN KEY (state_id) REFERENCES geo.states(state_id)
-- );
-- CREATE INDEX ix_models_model_type_id ON models(model_type_id);
-- CREATE INDEX ix_models_state_id ON models(state_id);
--
-- CREATE TABLE model_predictors (
--     model_id            SMALLINT NOT NULL,
--     predictor_id        SMALLINT NOT NULL,
--     created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
--     updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
--
--     CONSTRAINT pk_model_predictors PRIMARY KEY (model_id, predictor_id),
--     CONSTRAINT fk_model_predictors_model_id FOREIGN KEY (model_id) REFERENCES models(model_id),
--     CONSTRAINT fk_model_predictors_predictor_id FOREIGN KEY (predictor_id) REFERENCES predictors(predictor_id)
-- );
--
--
-- -- TODO: Determine if all predictors are floating point. If not then consider either separate tables or using JSON
-- CREATE TABLE site_predictors (
--     site_id             SMALLINT NOT NULL,
--     predictor_id        SMALLINT NOT NULL,
--     predictor_value     REAL,
--     created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
--     updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
--
--     CONSTRAINT pk_site_predictors PRIMARY KEY (site_id, predictor_id),
--     CONSTRAINT fk_site_predictors_site_id FOREIGN KEY (site_id) REFERENCES geo.sites(site_id),
--     CONSTRAINT fk_site_predictors_predictor_id FOREIGN KEY (predictor_id) REFERENCES predictors(predictor_id)
-- );


/******************************************************************************************************************
 ORGANISM SCHEMA
 */

CREATE SCHEMA taxa;
GRANT USAGE ON SCHEMA taxa TO PUBLIC;

CREATE TABLE taxa.taxa_levels(
    level_id            SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    level_name          VARCHAR(50) UNIQUE NOT NULL,
    parent_level_id     SMALLINT UNIQUE,
    is_active           BOOLEAN NOT NULL DEFAULT TRUE,
    description         TEXT,

    CONSTRAINT fk_taxa_levels_parent_level_id FOREIGN KEY (parent_level_id) REFERENCES taxa.taxa_levels(level_id)
);

CREATE TABLE taxa.life_stages (
    life_stage_id       SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    abbreviation        CHAR(1) UNIQUE NOT NULL,
    life_stage_name     VARCHAR(50) UNIQUE NOT NULL,
    is_active           BOOLEAN NOT NULL DEFAULT TRUE
);

CREATE TABLE taxa.taxonomy (
    taxonomy_id         SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    scientific_name     VARCHAR(255) NOT NULL,
    level_id            SMALLINT NOT NULL,
    parent_id           SMALLINT,
    author              VARCHAR(255),
    year                SMALLINT,
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_organism_taxonomy_taxa_level_id FOREIGN KEY (level_id) REFERENCES taxa.taxa_levels(level_id)
);
CREATE INDEX fx_organism_taxonomy_taxa_level_id ON taxa.taxonomy(level_id);

CREATE TABLE taxa.synonyms (
    synonym_id          SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    taxa_id             SMALLINT NOT NULL,
    synonym             VARCHAR(255) NOT NULL,

    CONSTRAINT fk_synonyms_taxa_id FOREIGN KEY (taxa_id) REFERENCES taxa.taxonomy(taxonomy_id)
);
CREATE INDEX fx_synonyms_taxa_id ON taxa.synonyms(taxa_id);

CREATE TYPE ATTRIBUTE_TYPES AS ENUM ('Float', 'Integer', 'Text', 'Unknown');


CREATE TABLE taxa.attributes (
    attribute_id        SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    attribute_name      VARCHAR(255) UNIQUE NOT NULL,
    attribute_type      ATTRIBUTE_TYPES NOT NULL,
    label               VARCHAR(255),
    description         TEXT,
    metadata            JSON,

    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE taxa.taxa_attributes (
    taxonomy_id         SMALLINT NOT NULL,
    attribute_id        SMALLINT NOT NULL,

    CONSTRAINT pk_taxa_attributes PRIMARY KEY (taxonomy_id, attribute_id),
    CONSTRAINT fk_taxa_attributes_taxonomy_id FOREIGN KEY (taxonomy_id) REFERENCES taxa.taxonomy(taxonomy_id),
    CONSTRAINT fk_taxa_attributes_attribute_id FOREIGN KEY (attribute_id) REFERENCES taxa.attributes(attribute_id)
);






/*
 ITIS
 Encyc of Life
 Wiki Species
 */
CREATE TABLE taxa.external_sources (
    source_id           SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    source_name         VARCHAR(255) UNIQUE NOT NULL,
    abbreviation        VARCHAR(10) UNIQUE NOT NULL,
    description         TEXT,
    metadata            JSONB
);

/*
 TSN is the ITIS primary key

 ITIS calls synonyms valid or invalid for up to date or older name.
 */
CREATE TABLE taxa.external_ids (
--     external_id         SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,


    source_id           SMALLINT NOT NULL,
    taxa_id             SMALLINT NOT NULL,
    external_source_id  VARCHAR(255),
    scientific_name     VARCHAR(255),

    CONSTRAINT pk_external_ids PRIMARY KEY (source_id, taxa_id),
    CONSTRAINT fk_external_ids_source_id FOREIGN KEY (source_id) REFERENCES taxa.external_sources(source_id),
    CONSTRAINT fk_external_ids_taxonomy_id FOREIGN KEY (taxa_id) REFERENCES taxa.taxonomy(taxonomy_id)
);

CREATE TABLE taxa.translations (
    translation_id      SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    translation_name    VARCHAR(255) UNIQUE NOT NULL,
    description         TEXT,
    is_active           BOOLEAN NOT NULL DEFAULT TRUE,

    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE taxa.taxa_translations (
    translation_id          SMALLINT NOT NULL,
    taxonomy_id             SMALLINT NOT NULL,
    translation_taxonomy_id SMALLINT NOT NULL,

    CONSTRAINT pk_taxa_translations PRIMARY KEY (translation_id, taxonomy_id),
    CONSTRAINT fk_taxa_translations_translation_id FOREIGN KEY (translation_id) REFERENCES taxa.translations(translation_id),
    CONSTRAINT fk_taxa_translations_taxonomy_id FOREIGN KEY (taxonomy_id) REFERENCES taxa.taxonomy(taxonomy_id),
    CONSTRAINT fk_taxa_translation_translation_taxonomy_id FOREIGN KEY (translation_taxonomy_id) REFERENCES taxa.taxonomy(taxonomy_id)
);
CREATE INDEX fx_taxa_translations_taxonomy_id ON taxa.taxa_translations(taxonomy_id);
CREATE INDEX fx_taxa_translations_translation_taxonomy_id ON taxa.taxa_translations(translation_taxonomy_id);

CREATE TABLE taxa.translation_indicators (
    translation_id          SMALLINT NOT NULL,
    indicator_id            SMALLINT NOT NULL,

    CONSTRAINT pk_taxa_translation_indicators PRIMARY KEY (translation_id, indicator_id),
    CONSTRAINT fk_taxa_translation_indicators_translation_id FOREIGN KEY (translation_id) REFERENCES taxa.translations(translation_id),
    CONSTRAINT fk_taxa_translation_indicators_indicator_id FOREIGN KEY (indicator_id) REFERENCES geo.indicators(indicator_id)
);

/******************************************************************************************************************
 SAMPLE SCHEMA
 */

CREATE SCHEMA sample;
GRANT USAGE ON SCHEMA sample TO PUBLIC;

CREATE TABLE sample.sample_methods (
    sample_method_id    SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    sample_method_name  VARCHAR(50) UNIQUE NOT NULL,
    is_active           BOOLEAN NOT NULL DEFAULT TRUE,
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE sample.sample_types (
    sample_type_id      SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    sample_type_name    VARCHAR(50) UNIQUE NOT NULL,
    is_active           BOOLEAN NOT NULL DEFAULT TRUE,
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE sample.box_states (
    box_state_id        SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    box_state_name      VARCHAR(50) UNIQUE NOT NULL,
    box_state_order     SMALLINT UNIQUE NOT NULL,
    description         TEXT,

    CONSTRAINT chk_box_states CHECK (box_state_order > 0)
);

CREATE TABLE sample.project_types (
    project_type_id     SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    project_type_name   VARCHAR(255) UNIQUE NOT NULL,
    description         TEXT
);

CREATE TABLE sample.projects (
    project_id          SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    project_name        VARCHAR(255) UNIQUE NOT NULL,
    project_type_id     SMALLINT NOT NULL,
    is_private          BOOLEAN DEFAULT TRUE,
    contact_id          SMALLINT,
    extent              GEOMETRY(MultiPolygon, 4326),
    auto_update_samples BOOLEAN NOT NULL DEFAULT FALSE,
    description         TEXT,
    metadata            JSON,
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_projects_contact_id FOREIGN KEY (contact_id) REFERENCES entity.entities(entity_id),
    CONSTRAINT fk_projects_project_type_id FOREIGN KEY (project_type_id) REFERENCES sample.project_types(project_type_id)
);
CREATE INDEX fx_projects_contact_id ON sample.projects(contact_id);
CREATE INDEX fx_projects_project_type_id ON sample.projects(project_type_id);
CREATE INDEX gx_projects_extent ON sample.projects USING GIST(extent);

-- TODO: table design incomplete
-- TODO: review columns copied from PilotDB.BugTacking
-- TODO: UsuTrack changed from FLOAT to SMALLINT
-- TODO: hook up billing_cust_id to customers? Confirm purpose
-- TODO: Default icost and tcost to zero?
-- TODO: tie
CREATE TABLE sample.boxes (
    box_id                      INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    customer_id                 SMALLINT NOT NULL,
    submitter_id                SMALLINT NOT NULL,
    box_state_id                SMALLINT NOT NULL,
    box_recevied_date           TIMESTAMPTZ, -- date the box arrives
    processing_complete_date    TIMESTAMPTZ, -- date lab processing is complete
    projected_complete_date     TIMESTAMPTZ, -- report_ready, available to customer, customer notified. all data QAed.
--     report_out          TIMESTAMPTZ, -- drop this column. use completed_date instead.
    sort_time           FLOAT, -- drop. Should be summation
    id_time             FLOAT, -- drop. should be summation
    description         TEXT,
    metadata            JSON,
    project_id          SMALLINT, -- changing this ID through the UI will need to change the sample_projects junction table
    measurements        BOOLEAN NOT NULL DEFAULT FALSE, -- things customers can be billed for (fee per sample) checkbox in submission UI
    sorter_qa           BOOLEAN NOT NULL DEFAULT FALSE, -- things customers can be billed for (fee per sample) checkbox in submission UI
    taxa_qa             BOOLEAN NOT NULL DEFAULT FALSE, -- things customers can be billed for (fee per sample) checkbox in submission UI
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_boxes_customer_id FOREIGN KEY (customer_id) REFERENCES entity.entities(entity_id),
    CONSTRAINT fk_boxes_creator_id FOREIGN KEY (submitter_id) REFERENCES entity.individuals(individual_id),
    CONSTRAINT fk_boxes_state_id FOREIGN KEY (box_state_id) REFERENCES sample.box_states(box_state_id),
    CONSTRAINT fk_boxes_project_id FOREIGN KEY (project_id) REFERENCES sample.projects(project_id)
);
CREATE INDEX fx_boxes_customer_id ON sample.boxes(customer_id);
CREATE INDEX fx_boxes_status_id ON sample.boxes(box_state_id);
CREATE INDEX fx_boxes_project_id ON sample.boxes(project_id);

CREATE TABLE sample.billing (
    billing_id          SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    box_id              INT NOT NULL,
    overhead            FLOAT, -- move to billing - meant to be the amount of time non tax or sort (labeling, QA)
    porder              VARCHAR(255), -- move to billing tables
    icost               FLOAT, -- move to billing tables
    tcost               SMALLINT, -- go into billing table
    billing_customer_id SMALLINT, -- goes into the billing tables

    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_billing_box_id FOREIGN KEY (box_id) REFERENCES sample.boxes(box_id)
);
CREATE INDEX fx_billing_box_id ON sample.billing(box_id);

-- TODO: do we need a similar "sample_submission_data" table?
CREATE TABLE sample.box_submission_data (
    box_id              INT NOT NULL PRIMARY KEY,
    metadata            JSONB NOT NULL,

    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_box_submission_data FOREIGN KEY (box_id) REFERENCES sample.boxes(box_id)
);

-- TODO: Verify that it's OK to make qualitative NOT NULL and check what the default should be
-- TODO: verify that Count field is not needed?
-- TODO: verify that SorterChironomidae is needed?
-- TODO: what is the field PilotDB.BugSample.MainID?
-- TODO: what is the field PilotDB.BugSample.LabID?
-- TODO: what is the field PilotDB.BugSample.Replicates?
-- TODO: what is the field PilotDB.BugSample.Archive?
-- TODO: I have converted mesh FROM FLOAT to SMALLINT. OK? Values are 56, 120, 180, 425
-- Jar count is the initial number of jars that the customer sends for each sample
CREATE TABLE sample.samples (
    sample_id           INT GENERATED BY DEFAULT AS IDENTITY,
    box_id              INT NOT NULL,
    site_id             SMALLINT,
    sample_date         DATE,
    sample_time         SMALLINT,
    type_id             SMALLINT NOT NULL,
    method_id           SMALLINT NOT NULL,
    habitat_id          SMALLINT NOT NULL,
    area                REAL,
    field_split         REAL,
    field_notes         TEXT,
    lab_split           REAL,
    jar_count           SMALLINT NOT NULL DEFAULT 1,
    qualitative         BOOLEAN DEFAULT FALSE,
    lab_notes           TEXT,
    mesh                SMALLINT,
    sorter_count        SMALLINT,
    sorter_id           SMALLINT,
    sort_time           REAL NOT NULL DEFAULT 0,
    sort_start_date     TIMESTAMPTZ,
    sort_end_date       TIMESTAMPTZ,
    ider_id             SMALLINT,
    id_time             REAL NOT NULL DEFAULT 0,
    id_start_date       TIMESTAMPTZ,
    id_end_date         TIMESTAMPTZ,
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    qa_sample_id        SMALLINT,
    lab_id              SMALLINT,
    metadata            JSON,

    CONSTRAINT pk_samples PRIMARY KEY (sample_id),
    CONSTRAINT fk_samples_box_id FOREIGN KEY (box_id) REFERENCES sample.boxes(box_id),
    CONSTRAINT fk_samples_site_id FOREIGN KEY (site_id) REFERENCES geo.sites(site_id),
    CONSTRAINT fk_samples_type_id FOREIGN KEY (type_id) REFERENCES sample.sample_types(sample_type_id),
    CONSTRAINT fk_samples_method_id FOREIGN KEY (method_id) REFERENCES sample.sample_methods(sample_method_id),
    CONSTRAINT fk_samples_habitat_id FOREIGN KEY (habitat_id) REFERENCES geo.habitats(habitat_id),
    CONSTRAINT fk_samples_sorter_id FOREIGN KEY (sorter_id) REFERENCES entity.individuals(individual_id),
    CONSTRAINT fk_samples_ider_id FOREIGN KEY (ider_id) REFERENCES entity.individuals(individual_id),
    CONSTRAINT fk_samples_lab_id FOREIGN KEY (lab_id) REFERENCES entity.organizations(organization_id),
    CONSTRAINT ck_samples_area CHECK (area >= 0),
    CONSTRAINT ck_samples_field_split CHECK (field_split >= 0),
    CONSTRAINT ck_samples_lab_split CHECK (lab_split >= 0),
    CONSTRAINT chk_samples_sorter_count CHECK (sorter_count >= 0),
    CONSTRAINT chk_samples_mesh CHECK (mesh > 0),
    CONSTRAINT chk_samples_jar_count CHECK (jar_count > 0)
);
CREATE INDEX fx_samples_box_id ON sample.samples(box_id);
CREATE INDEX fx_samples_site_id ON sample.samples(site_id);
CREATE INDEX fx_samples_type_id ON sample.samples(type_id);
CREATE INDEX fx_samples_method_id ON sample.samples(method_id);
CREATE INDEX fx_samples_habitat_id ON sample.samples(habitat_id);
CREATE INDEX fx_samples_lab_id ON sample.samples(lab_id);

CREATE TYPE TOW_TYPES AS ENUM ('Vertical', 'Horizontal');

CREATE TABLE sample.sample_labs (
    sample_id           INT NOT NULL,
    organization_id     SMALLINT NOT NULL,
    lab_type_id         SMALLINT NOT NULL,

    CONSTRAINT pk_sample_labs PRIMARY KEY (sample_id, organization_id, lab_type_id),
    CONSTRAINT fk_sample_labs_sample_id FOREIGN KEY (sample_id) REFERENCES sample.samples(sample_id),
    CONSTRAINT fk_sample_labs_entity_id FOREIGN KEY (organization_id) REFERENCES entity.organizations(organization_id),
    CONSTRAINT fk_sample_labs_lab_type_id FOREIGN KEY (lab_type_id) REFERENCES entity.lab_types(lab_type_id)
);

-- TODO: move fields from sample.samples to this table
CREATE TABLE sample.benthic (
    sample_id           INT NOT NULL PRIMARY KEY,
    notes               TEXT,
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_sample_benthic_sample_id FOREIGN KEY (sample_id) REFERENCES sample.samples(sample_id)
);

CREATE TABLE sample.plantkton (
    sample_id           INT NOT NULL PRIMARY KEY,
    diameter            REAL,
    sub_sample_count    SMALLINT,
    tow_length          REAL,
    volume              REAL,
    all_quot            REAL,
    size_interval       REAL,
    tow_type            TOW_TYPES,
    notes               TEXT,
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_plankton_sample_id FOREIGN KEY (sample_id) REFERENCES sample.samples(sample_id),
    CONSTRAINT ck_plankton_diameter CHECK (diameter >= 0),
    CONSTRAINT ck_plankton_sub_sample_count CHECK (sub_sample_count >= 0),
    CONSTRAINT ck_plankton_tow_length CHECK (tow_length >= 0),
    CONSTRAINT ck_plankton_volume CHECK (volume >=0),
    CONSTRAINT ck_plankton_size_interval CHECK (size_interval >= 0)
);

-- TODO: confirm that velo means velocity
CREATE TABLE sample.drift (
    sample_id           INT NOT NULL PRIMARY KEY,
    diameter            FLOAT,
    net_time            FLOAT,
    stream_depth        FLOAT,
    net_depth           FLOAT,
    net_velo            FLOAT,
    notes               TEXT,
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT ck_bug_drift_diameter CHECK (diameter > 0),
    CONSTRAINT ck_bug_drift_net_time CHECK (net_time > 0),
    CONSTRAINT ck_bug_drift_stream_depth CHECK (stream_depth > 0),
    CONSTRAINT ck_bug_drift_net_depth CHECK (net_depth > 0),
    CONSTRAINT ck_bug_drift_net_velo CHECK (net_velo >= 0)
);


CREATE TABLE sample.organic_matter_types (
    organic_id     SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    organic_name   VARCHAR(20) UNIQUE NOT NULL
);

CREATE TABLE sample.mass_methods (
    mass_method_id      SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    mass_method_name    VARCHAR(255) UNIQUE NOT NULL,
    abbreviation        VARCHAR(15) UNIQUE NOT NULL,
    is_active           BOOLEAN NOT NULL DEFAULT TRUE
);

CREATE TABLE sample.mass_types (
    mass_type_id      SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    mass_type_name  VARCHAR(255) UNIQUE NOT NULL,
    abbreviation    VARCHAR(15) UNIQUE NOT NULL,
    is_active       BOOLEAN NOT NULL DEFAULT TRUE
);

/*
 AFDM = Ash free dry mass
 The old bug o matter table used to have AFDM column. IT was a sum of several
 different kinds of mass.
 */
CREATE TABLE sample.organic_matter (
    sample_id           INT NOT NULL PRIMARY KEY,
    organic_id          SMALLINT NOT NULL,
    mass                REAL NOT NULL,
    notes               TEXT,

    CONSTRAINT fk_bug_o_matter FOREIGN KEY (sample_id) REFERENCES sample.samples(sample_id),
    CONSTRAINT fk_bug_o_matter_organic_id FOREIGN KEY (organic_id) REFERENCES sample.organic_matter_types(organic_id)
);
CREATE INDEX fx_bug_o_matter_organic_id ON sample.organic_matter(organic_id);

-- TODO: What other fields are needed on this table?
CREATE TABLE sample.water (
    sample_id           INT NOT NULL PRIMARY KEY

);

-- TODO PilotDB.Stomachs.Code is NULL and the species column has species as text
CREATE TABLE sample.stomachs (
    sample_id           INT NOT NULL PRIMARY KEY,
    taxonomy_id         SMALLINT NOT NULL,
    fish_length         REAL,
    fish_mass           REAL,
    notes               TEXT,
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_stomachs_sample_id FOREIGN KEY (sample_id) REFERENCES sample.samples(sample_id),
    CONSTRAINT fk_stomaches_taxonomy_id FOREIGN KEY (taxonomy_id) REFERENCES taxa.taxonomy(taxonomy_id),
    CONSTRAINT ck_stomachs_fish_length CHECK (fish_length >= 0),
    CONSTRAINT ck_stomachs_fish_mass CHECK (fish_mass >= 0)
);
CREATE INDEX stomachs_taxa_id ON sample.stomachs(taxonomy_id);


CREATE TABLE sample.sort_qa (
    sample_id           INT NOT NULL PRIMARY KEY,
    sorter2_id          SMALLINT NOT NULL,
    sorted_date         TIMESTAMPTZ NOT NULL,
    bugs_resorted       SMALLINT NOT NULL,
    sorter_efficiency   REAL,
    elutriation         BOOLEAN NOT NULL,
    split               REAL,
    sort_time           REAL,
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_sample_sort_qa_sorter2_id FOREIGN KEY (sorter2_id) REFERENCES entity.individuals(individual_id),
    CONSTRAINT ck_sample_sort_qa_bugs_resorted CHECK ( bugs_resorted >= 0),
    CONSTRAINT ck_sample_sort_qa_sorter_efficiency CHECK ((sorter_efficiency >= 0) AND (sorter_efficiency <= 100)),
    CONSTRAINT ck_sample_qaqc_qaqc_split CHECK ((split >=0) AND (split <= 100)),
    CONSTRAINT ck_sample_qaqc_sort_time CHECK ((sort_time>=0) AND (sort_time < 24))
);

-- TODO: maybe could be descriptive text instead? 'BEFORE RECONCILIATION' and 'AFTER RECONCILIATION'
CREATE TYPE QA_STAGES AS ENUM ('Before Reconciliation', 'After Reconciliation');

-- TODO: old table has OTUCode. What should this be now?
-- TODO: taxa_qa data type and reference?
-- TODO: should ider1 and ider2 be NOT NULL?
-- TODO: should ptd_class, bray_curtis_class and pde_class be boolean, enum or lookup?
-- TODO: constraints on the numerical fields
CREATE TABLE sample.taxa_qa (
    sample_id           INT NOT NULL PRIMARY KEY,
    taxa_qa             SMALLINT,
    taxa_qa_stage       QA_STAGES,
    start_date          TIMESTAMPTZ NOT NULL DEFAULT now(),
    ider1               SMALLINT NOT NULL,
    ider2               SMALLINT,
    sorter_count_diff   SMALLINT,
    taxa_count_diff     SMALLINT,
    code_count          SMALLINT,
    bray_curtis         REAL,
    bray_curtis_class   BOOLEAN,
    ptd                 REAL,
    ptd_class           BOOLEAN,
    pde                 REAL,
    pde_class           BOOLEAN,
    ptc1                REAL,
    ptc2                REAL,
    notes               TEXT,
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_sample_taxa_qa_ider1 FOREIGN KEY (ider1) REFERENCES entity.individuals(individual_id),
    CONSTRAINT fk_sample_taxa_qa_ider2 FOREIGN KEY (ider2) REFERENCES entity.individuals(individual_id)
);
CREATE INDEX fx_sample_taxa_qa_ider1 ON sample.taxa_qa(ider1);
CREATE INDEX fx_sample_taxa_qa_ider2 ON sample.taxa_qa(ider2);

/*
 The Valid column is not currently used. But its there to invalidate
 a certain row, and then ignore it from all the subsequent processes.

 Currently delete the data if it is not valid. This was done infrequently
 as part of large QA efforts across big datasets.

 Experiment with using a date for invalidating a record. This can
 then reveal in a report whether the metrics predate a record
 getting eliminated.
 */
CREATE TABLE sample.organisms (
    organism_id         INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    sample_id           INT NOT NULL,
    taxonomy_id         SMALLINT NOT NULL,
    life_stage_id       SMALLINT NOT NULL,
    bug_size            REAL,

    split_count         REAL,
    big_rare_count      SMALLINT,
    invalidated_date    TIMESTAMPTZ,
    notes               TEXT,
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_organisms_sample_id FOREIGN KEY (sample_id) REFERENCES sample.samples(sample_id),
    CONSTRAINT fk_organisms_taxonomy_id FOREIGN KEY (taxonomy_id) REFERENCES taxa.taxonomy(taxonomy_id),
    CONSTRAINT fk_organisms_life_stage_id FOREIGN KEY (life_stage_id) REFERENCES taxa.life_stages(life_stage_id)
);


CREATE UNIQUE INDEX ux_organism_organisms ON sample.organisms(sample_id, taxonomy_id, life_stage_id, bug_size);

CREATE TABLE sample.note_types (
    note_id             SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    note_name           VARCHAR(25) UNIQUE NOT NULL,
    abbreviation        CHAR(1) UNIQUE NOT NULL,
    description         TEXT,

    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE sample.organism_notes (
    organism_id         INT NOT NULL,
    note_id             SMALLINT NOT NULL,

    CONSTRAINT pk_organism_types PRIMARY KEY (organism_id, note_id),
    CONSTRAINT fk_organism_types_organism_id FOREIGN KEY (organism_id) REFERENCES sample.organisms(organism_id),
    CONSTRAINT fk_organism_types_note_id FOREIGN KEY (note_id) REFERENCES sample.note_types(note_id)
);

-- TODO: would this table be better named as sample.asset_types
CREATE TABLE sample.assets (
    asset_id            SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    asset_name          VARCHAR(255) NOT NULL UNIQUE,
    description         TEXT,

    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE sample.sample_assets (
    sample_id           INT NOT NULL,
    asset_id            INT NOT NULL,

    CONSTRAINT pk_sample_assets PRIMARY KEY (sample_id, asset_id),
    CONSTRAINT fk_sample_assets_sample_id FOREIGN KEY (sample_id) REFERENCES sample.samples(sample_id),
    CONSTRAINT fk_sample_assets_asset_id FOREIGN KEY (asset_id) REFERENCES sample.assets(asset_id)
);

CREATE TABLE sample.sample_indicators (
    sample_id           INT NOT NULL,
    indicator_id        SMALLINT NOT NULL,
    location            GEOMETRY(Point, 4326) NOT NULL,
    catchment           GEOMETRY(MultiPolygon, 4326) NOT NULL,
    metadata            JSONB,
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE INDEX gx_sites_location ON sample.sample_indicators USING GIST(location);
CREATE INDEX gx_sites_catchment ON sample.sample_indicators USING GIST(catchment);

CREATE TABLE sample.project_samples (
    project_id          SMALLINT NOT NULL,
    sample_id           INT NOT NULL,

    CONSTRAINT pk_project_samples PRIMARY KEY (project_id, sample_id),
    CONSTRAINT fk_projct_samples_sample_id FOREIGN KEY (sample_id) REFERENCES sample.samples(sample_id),
    CONSTRAINT fk_project_samples_project_id FOREIGN KEY (project_id) REFERENCES sample.projects(project_id)
);

/******************************************************************************************************************
 METRIC SCHEMA
 */

CREATE SCHEMA metric;
GRANT USAGE ON SCHEMA metric TO PUBLIC;

CREATE TABLE metric.metric_types (
    metric_type_id      SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    metric_name         VARCHAR(255) UNIQUE NOT NULL,
    description         TEXT,
    unit_id             SMALLINT NOT NULL,

    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_metric_types_unit_id FOREIGN KEY (unit_id) REFERENCES geo.units(unit_id)
);
CREATE INDEX fx_metric_types_unit_id ON metric.metric_types(unit_id);

CREATE TABLE metric.metrics (
    metric_id           INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    sample_id           INT NOT NULL,
    metric_type_id      SMALLINT NOT NULL,
    translation_id      SMALLINT NOT NULL,

    CONSTRAINT fk_metrics_sample_id FOREIGN KEY (sample_id) REFERENCES sample.samples(sample_id),
    CONSTRAINT fk_metrics_metric_type_id FOREIGN KEY (metric_type_id) REFERENCES metric.metric_types(metric_type_id),
    CONSTRAINT fk_metrics_translation_id FOREIGN KEY (translation_id) REFERENCES taxa.translations(translation_id)
);
CREATE INDEX fx_metrics_metric_type_id ON metric.metrics(metric_type_id);

CREATE TABLE metric.reports (
    report_id           SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    report_name         VARCHAR(255) UNIQUE NOT NULL,
    description         TEXT,
    is_active           BOOLEAN NOT NULL DEFAULT TRUE,

    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE metric.analysis_types (
    analysis_type_id    SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    analysis_type_name  VARCHAR(255) UNIQUE NOT NULL,
    report_id           SMALLINT NOT NULL,

    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_analysis_types_report_id FOREIGN KEY (report_id) REFERENCES metric.reports(report_id)
);
CREATE INDEX fx_analysis_types_report_id ON metric.analysis_types(report_id);

CREATE TABLE metric.analyses (
    analysis_id      INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    analysis_type_id SMALLINT NOT NULL,

    created_date     TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date     TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_analyses_analysis_type_id FOREIGN KEY (analysis_id) REFERENCES metric.analysis_types (analysis_type_id)
);
