CREATE EXTENSION postgis;
CREATE EXTENSION tablefunc;


CREATE FUNCTION fn_before_update()
RETURNS trigger AS
    $$
    BEGIN
        NEW.updated_date = now();
        RETURN NEW;
    END ;
$$
LANGUAGE 'plpgsql';

-- /******************************************************************************************************************
--  METADATA SCHEMA
--  */
--
CREATE SCHEMA meta;
GRANT USAGE ON SCHEMA meta TO PUBLIC;

CREATE TABLE meta.schemas (
    schema_id           SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    schema_name         VARCHAR(20) UNIQUE NOT NULL,
    diagram_url         varchar(255),
    description         TEXT
);

CREATE TABLE meta.tables (
    table_id            SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    table_name          VARCHAR(50) UNIQUE NOT NULL,
    schema_id           SMALLINT NOT NULL,
    description         TEXT,
    source_data         TEXT,

    CONSTRAINT fk_meta_tables_schema_id FOREIGN KEY (schema_id) REFERENCES meta.schemas(schema_id)
);
CREATE INDEX fx_meta_tables_schema_id ON meta.tables(schema_id);

/******************************************************************************************************************
 GEO SCHEMA
 */

CREATE SCHEMA geo;
GRANT USAGE ON SCHEMA geo TO PUBLIC;

CREATE TABLE geo.countries (
    country_id          SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    country_name        VARCHAR(50) UNIQUE NOT NULL,
    abbreviation        VARCHAR(5) NOT NULL,
    geom                GEOMETRY(MultiPolygon, 4326),
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE INDEX gx_countries_geom ON geo.countries USING GIST(geom);
CREATE TRIGGER tr_countries_update BEFORE UPDATE ON geo.countries FOR EACH ROW EXECUTE PROCEDURE fn_before_update();

CREATE TABLE geo.states (
    state_id            SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    country_id          SMALLINT NOT NULL,
    state_name          VARCHAR(50) NOT NULL,
    abbreviation        VARCHAR(2) NOT NULL,
    geom                GEOMETRY(MultiPolygon, 4326),
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_states_country_id FOREIGN KEY (country_id) REFERENCES geo.countries(country_id)
);
CREATE INDEX ix_states_country_id ON geo.states(country_id);
CREATE UNIQUE INDEX ux_states_name ON geo.states(country_id, state_name);
CREATE UNIQUE INDEX ux_states_abbreviation ON geo.states(country_id, abbreviation);
CREATE INDEX gx_states_geom ON geo.states USING GIST(geom);
CREATE TRIGGER tr_states_update BEFORE UPDATE ON geo.states FOR EACH ROW EXECUTE PROCEDURE fn_before_update();


CREATE TABLE geo.counties (
    county_id           SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    state_id            SMALLINT NOT NULL,
    county_name         VARCHAR(255) NOT NULL,
    geom                GEOMETRY(MultiPolygon, 4326),
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_counties_state_id FOREIGN KEY (state_id) REFERENCES geo.states(state_id)
);
CREATE INDEX ix_counties_state_id ON geo.counties(state_id);
CREATE UNIQUE INDEX ux_counties_name ON geo.counties(state_id, county_name);
CREATE INDEX gx_counties_geom ON geo.counties USING GIST(geom);
CREATE TRIGGER tr_counties_update BEFORE UPDATE ON geo.counties FOR EACH ROW EXECUTE PROCEDURE fn_before_update();


CREATE TABLE geo.land_uses (
    land_use_id         SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    land_use_name       VARCHAR(50) UNIQUE NOT NULL,
    is_active           BOOLEAN NOT NULL DEFAULT TRUE,
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE TRIGGER tr_land_uses_update BEFORE UPDATE ON geo.land_uses FOR EACH ROW EXECUTE PROCEDURE fn_before_update();


CREATE TABLE geo.ecosystems (
    ecosystem_id        SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    ecosystem_name      VARCHAR(10) UNIQUE NOT NULL,
    is_active           BOOLEAN NOT NULL DEFAULT TRUE,
    description         TEXT,
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE TRIGGER tr_ecosystems_update BEFORE UPDATE ON geo.ecosystems FOR EACH ROW EXECUTE PROCEDURE fn_before_update();


CREATE TABLE geo.habitats (
    habitat_id          SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    habitat_name        VARCHAR(50) UNIQUE NOT NULL,
    ecosystem_id        SMALLINT NOT NULL,
    is_active           BOOLEAN NOT NULL DEFAULT TRUE,
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_habitats_ecosystem_id FOREIGN KEY (ecosystem_id) REFERENCES geo.ecosystems(ecosystem_id)
);
CREATE INDEX ix_habitats_ecosystem_id ON geo.habitats(ecosystem_id);
CREATE TRIGGER tr_habitats_update BEFORE UPDATE ON geo.habitats FOR EACH ROW EXECUTE PROCEDURE fn_before_update();


CREATE TABLE geo.units (
    unit_id             SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    unit_name           VARCHAR(50) UNIQUE NOT NULL,
    abbreviation        VARCHAR(10) UNIQUE NOT NULL,
    description         TEXT,
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE TRIGGER tr_units_update BEFORE UPDATE ON geo.units FOR EACH ROW EXECUTE PROCEDURE fn_before_update();


CREATE TABLE geo.systems (
    system_id           SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    system_name         VARCHAR(20) UNIQUE NOT NULL,
    ecosystem_id        SMALLINT NOT NULL,
    is_active           BOOLEAN NOT NULL DEFAULT TRUE,
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_systems_ecosystem_id FOREIGN KEY (ecosystem_id) REFERENCES geo.ecosystems(ecosystem_id)
);
CREATE INDEX ix_systems_ecosystem_id ON geo.systems(ecosystem_id);
CREATE TRIGGER tr_systems_update BEFORE UPDATE ON geo.systems FOR EACH ROW EXECUTE PROCEDURE fn_before_update();


-- TODO: table design incomplete
CREATE TABLE geo.sites (
    site_id             INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    site_name           VARCHAR(50) UNIQUE NOT NULL,
    system_id           SMALLINT,
    ecosystem_id        SMALLINT,
    description         TEXT,
    waterbody           VARCHAR(255),
    location            GEOMETRY(Point, 4326) NOT NULL,
    catchment           GEOMETRY(MultiPolygon, 4326),
    NHDPlusID           BIGINT,
    COMID               BIGINT,
    metadata            JSON,
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_sites_system_id FOREIGN KEY (system_id) REFERENCES geo.systems(system_id),
    CONSTRAINT fk_sites_ecosystem_id FOREIGN KEY (ecosystem_id) REFERENCES geo.ecosystems(ecosystem_id)
);
CREATE INDEX gx_sites_location ON geo.sites USING GIST(location);
CREATE INDEX gx_sites_catchment ON geo.sites USING GIST(catchment);
CREATE INDEX fx_sites_systems ON geo.sites(system_id);
CREATE INDEX fx_sites_ecosystems ON geo.sites(ecosystem_id);
CREATE TRIGGER tr_sites_update BEFORE UPDATE ON geo.sites FOR EACH ROW EXECUTE PROCEDURE fn_before_update();


CREATE TABLE geo.predictor_types (
    predictor_type_id   SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    predictor_type_name VARCHAR(255) UNIQUE NOT NULL,
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE TRIGGER tr_predictor_types_update BEFORE UPDATE ON geo.predictor_types FOR EACH ROW EXECUTE PROCEDURE fn_before_update();


CREATE TABLE geo.predictors (
    predictor_id        SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    predictor_name      VARCHAR(255) UNIQUE NOT NULL,
    abbreviation        VARCHAR(25) UNIQUE NOT NULL,
    unit_id             SMALLINT NOT NULL,
    predictor_type_id   SMALLINT NOT NULL,
    description         TEXT,
    metadata            JSON,
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_predictors_unit_id FOREIGN KEY (unit_id) REFERENCES geo.units(unit_id),
    CONSTRAINT fk_predictors_predictor_type_id FOREIGN KEY (predictor_type_id) REFERENCES geo.predictor_types(predictor_type_id)
);
CREATE INDEX fx_predictors_unit_id ON geo.predictors(unit_id);
CREATE INDEX fk_predictors_predictor_type_id ON geo.predictors(predictor_type_id);
CREATE TRIGGER tr_predictors_update BEFORE UPDATE ON geo.predictors FOR EACH ROW EXECUTE PROCEDURE fn_before_update();


CREATE TABLE geo.site_predictors (
    predictor_id        SMALLINT NOT NULL,
    site_id             INT NOT NULL,
    metadata            JSONB NOT NULL,
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT pk_site_predictors PRIMARY KEY (predictor_id, site_id),
    CONSTRAINT fk_site_predictors FOREIGN KEY (predictor_id) REFERENCES geo.predictors(predictor_id),
    CONSTRAINT fk_site_site_id FOREIGN KEY (site_id) REFERENCES geo.sites(site_id)
);
CREATE TRIGGER tr_site_predictors_update BEFORE UPDATE ON geo.site_predictors FOR EACH ROW EXECUTE PROCEDURE fn_before_update();


/******************************************************************************************************************
 ENTITY SCHEMA
 */

CREATE SCHEMA entity;
GRANT USAGE ON SCHEMA entity TO PUBLIC;
-- ALTER DEFAULT PRIVILEGES IN SCHEMA entity GRANT ALL ON TABLES TO PUBLIC;

CREATE TABLE entity.entities (
    entity_id           SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    parent_id           SMALLINT,
    address1            VARCHAR(255),
    address2            VARCHAR(255),
    city                VARCHAR(255),
    state_id            SMALLINT,
    country_id          SMALLINT NOT NULL,
    zip_code            VARCHAR(20),
    phone               VARCHAR(50),
    fax                 VARCHAR(50),
    website             VARCHAR(255),
    notes               TEXT,
    metadata            JSON,
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_entities_parent_id FOREIGN KEY (parent_id) REFERENCES entity.entities(entity_id),
    CONSTRAINT fk_entities_state_id FOREIGN KEY (state_id) REFERENCES geo.states(state_id),
    CONSTRAINT fk_entities_country_id FOREIGN KEY (country_id) REFERENCES geo.countries(country_id)
);
CREATE INDEX fx_entities_state_id ON entity.entities(state_id);
CREATE INDEX fx_entities_country_id ON entity.entities(country_id);
CREATE TRIGGER tr_entities_update BEFORE UPDATE ON entity.entities FOR EACH ROW EXECUTE PROCEDURE fn_before_update();

CREATE TABLE entity.organization_types (
    organization_type_id    SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    organization_type_name  VARCHAR(50) UNIQUE NOT NULL
);

CREATE TABLE entity.organizations (
    organization_id         SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    abbreviation            VARCHAR(50),
    organization_name       VARCHAR(255),
    entity_id               SMALLINT NOT NULL,
    organization_type_id    SMALLINT NOT NULL,
    is_lab                  BOOLEAN NOT NULL DEFAULT FALSE,

    CONSTRAINT fk_organizations_entity_id FOREIGN KEY (entity_id) REFERENCES entity.entities(entity_id) ON DELETE CASCADE,
    CONSTRAINT fk_organizations_organization_type_id FOREIGN KEY (organization_type_id) REFERENCES entity.organization_types(organization_type_id)
);
CREATE UNIQUE INDEX ux_organizations_entity_id ON entity.organizations(entity_id);
CREATE INDEX fx_organizations_organization_type_id ON entity.organizations(organization_type_id);

-- TODO: table design incomplete. Need to implement roles here.
-- TODO: do we really need gender and other non-bug identification information
CREATE TABLE entity.individuals (
    individual_id       SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    first_name          VARCHAR(50) NOT NULL,
    last_name           VARCHAR(50) NOT NULL,
    initials            VARCHAR(3),
    entity_id           SMALLINT NOT NULL,
    affiliation_id      SMALLINT,
    email               VARCHAR(255),
    title               VARCHAR(255),
    cognito_sub         VARCHAR(255),

    CONSTRAINT fk_individuals_entity_id FOREIGN KEY (entity_id) REFERENCES entity.entities(entity_id) ON DELETE CASCADE,
    CONSTRAINT fk_individuals_affiliation_id FOREIGN KEY (affiliation_id) REFERENCES entity.organizations(organization_id)
);
CREATE UNIQUE INDEX ux_individuals_entity_id ON entity.individuals(entity_id);
CREATE INDEX fx_individuals_affiliation_id ON entity.individuals(affiliation_id);

CREATE TABLE entity.roles (
    role_id             SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    role_name           VARCHAR(255) UNIQUE NOT NULL,
    description         TEXT
);

CREATE TABLE entity.individual_roles (
    individual_id       SMALLINT NOT NULL,
    role_id             SMALLINT NOT NULL,

    CONSTRAINT pk_individuals_roles PRIMARY KEY (individual_id, role_id),
    CONSTRAINT fk_individual_roles_individual_id FOREIGN KEY (individual_id) REFERENCES entity.individuals(individual_id) ON DELETE CASCADE,
    CONSTRAINT fk_individual_roles_role_id FOREIGN KEY (role_id) REFERENCES entity.roles(role_id)
);


CREATE TABLE entity.communications (
    history_id          INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    entity_id           SMALLINT,
    employee_id         SMALLINT NOT NULL,
    notes               TEXT,
    metadata            JSON,
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_history_entity_id FOREIGN KEY (entity_id) REFERENCES entity.entities(entity_id),
    CONSTRAINT fk_history_namc_staff_id FOREIGN KEY (employee_id) REFERENCES entity.individuals(individual_id)
);
CREATE INDEX fx_entities_history_entity_id ON entity.communications(entity_id);
CREATE INDEX fx_entities_history_employee_id ON entity.communications(employee_id);


CREATE TABLE entity.lab_types (
    lab_type_id         SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    lab_type_name       VARCHAR(255) UNIQUE NOT NULL
);

/******************************************************************************************************************
 Taxa SCHEMA
 */

CREATE SCHEMA taxa;
GRANT USAGE ON SCHEMA taxa TO PUBLIC;

CREATE TABLE taxa.taxa_levels(
    level_id            SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    level_name          VARCHAR(50) UNIQUE NOT NULL,
    parent_level_id     SMALLINT UNIQUE,
    is_active           BOOLEAN NOT NULL DEFAULT TRUE,
    description         TEXT,

    CONSTRAINT fk_taxa_levels_parent_level_id FOREIGN KEY (parent_level_id) REFERENCES taxa.taxa_levels(level_id)
);

CREATE TABLE taxa.life_stages (
    life_stage_id       SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    abbreviation        CHAR(1) UNIQUE NOT NULL,
    life_stage_name     VARCHAR(50) UNIQUE NOT NULL,
    is_active           BOOLEAN NOT NULL DEFAULT TRUE
);

CREATE TABLE taxa.taxonomy (
    taxonomy_id         SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    scientific_name     VARCHAR(255) NOT NULL,
    level_id            SMALLINT NOT NULL,
    parent_id           SMALLINT,
    author              VARCHAR(255),
    year                SMALLINT,
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_organism_taxonomy_taxa_level_id FOREIGN KEY (level_id) REFERENCES taxa.taxa_levels(level_id)
);
CREATE INDEX fx_organism_taxonomy_taxa_level_id ON taxa.taxonomy(level_id);
CREATE TRIGGER tr_taxonomy_update BEFORE UPDATE ON taxa.taxonomy FOR EACH ROW EXECUTE PROCEDURE fn_before_update();


CREATE TABLE taxa.synonyms (
    synonym_id          SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    taxonomy_id             SMALLINT NOT NULL,
    synonym             VARCHAR(255) NOT NULL,

    CONSTRAINT fk_synonyms_taxonomy_id FOREIGN KEY (taxonomy_id) REFERENCES taxa.taxonomy(taxonomy_id) ON DELETE CASCADE
);
CREATE INDEX fx_synonyms_taxonomy_id ON taxa.synonyms(taxonomy_id);

CREATE TYPE ATTRIBUTE_TYPES AS ENUM ('Float', 'Integer', 'Text', 'Unknown');


CREATE TABLE taxa.attributes (
    attribute_id        SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    attribute_name      VARCHAR(255) UNIQUE NOT NULL,
    attribute_type      ATTRIBUTE_TYPES NOT NULL,
    label               VARCHAR(255),
    description         TEXT,
    metadata            JSON,

    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE TRIGGER tr_attributes_update BEFORE UPDATE ON taxa.attributes FOR EACH ROW EXECUTE PROCEDURE fn_before_update();


CREATE TABLE taxa.taxa_attributes (
    taxonomy_id         SMALLINT NOT NULL,
    attribute_id        SMALLINT NOT NULL,
    attribute_value     VARCHAR(100) NOT NULL,

    CONSTRAINT pk_taxa_attributes PRIMARY KEY (taxonomy_id, attribute_id),
    CONSTRAINT fk_taxa_attributes_taxonomy_id FOREIGN KEY (taxonomy_id) REFERENCES taxa.taxonomy(taxonomy_id) ON DELETE CASCADE,
    CONSTRAINT fk_taxa_attributes_attribute_id FOREIGN KEY (attribute_id) REFERENCES taxa.attributes(attribute_id)
);

/*
 ITIS
 Encyc of Life
 Wiki Species
 */
CREATE TABLE taxa.external_sources (
    source_id           SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    source_name         VARCHAR(255) UNIQUE NOT NULL,
    abbreviation        VARCHAR(10) UNIQUE NOT NULL,
    description         TEXT,
    metadata            JSONB
);

/*
 TSN is the ITIS primary key

 ITIS calls synonyms valid or invalid for up to date or older name.
 */
CREATE TABLE taxa.external_ids (
--     external_id         SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

    source_id           SMALLINT NOT NULL,
    taxonomy_id             SMALLINT NOT NULL,
    external_source_id  VARCHAR(255),
    scientific_name     VARCHAR(255),

    CONSTRAINT pk_external_ids PRIMARY KEY (source_id, taxonomy_id),
    CONSTRAINT fk_external_ids_source_id FOREIGN KEY (source_id) REFERENCES taxa.external_sources(source_id) ON DELETE CASCADE,
    CONSTRAINT fk_external_ids_taxonomy_id FOREIGN KEY (taxonomy_id) REFERENCES taxa.taxonomy(taxonomy_id)
);

CREATE TABLE taxa.translations (
    translation_id      SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    translation_name    VARCHAR(255) UNIQUE NOT NULL,
    description         TEXT,
    is_active           BOOLEAN NOT NULL DEFAULT TRUE,

    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE TRIGGER tr_translations_update BEFORE UPDATE ON taxa.translations FOR EACH ROW EXECUTE PROCEDURE fn_before_update();


CREATE TABLE taxa.taxa_translations (
    translation_id          SMALLINT NOT NULL,
    taxonomy_id             SMALLINT NOT NULL,
    translation_taxonomy_id SMALLINT NOT NULL,

    CONSTRAINT pk_taxa_translations PRIMARY KEY (translation_id, taxonomy_id),
    CONSTRAINT fk_taxa_translations_translation_id FOREIGN KEY (translation_id) REFERENCES taxa.translations(translation_id) ON DELETE CASCADE,
    CONSTRAINT fk_taxa_translations_taxonomy_id FOREIGN KEY (taxonomy_id) REFERENCES taxa.taxonomy(taxonomy_id),
    CONSTRAINT fk_taxa_translation_translation_taxonomy_id FOREIGN KEY (translation_taxonomy_id) REFERENCES taxa.taxonomy(taxonomy_id)
);
CREATE INDEX fx_taxa_translations_taxonomy_id ON taxa.taxa_translations(taxonomy_id);
CREATE INDEX fx_taxa_translations_translation_taxonomy_id ON taxa.taxa_translations(translation_taxonomy_id);

CREATE TABLE taxa.translation_predictors (
    translation_id          SMALLINT NOT NULL,
    predictor_id            SMALLINT NOT NULL,

    CONSTRAINT pk_taxa_translation_predictors PRIMARY KEY (translation_id, predictor_id),
    CONSTRAINT fk_taxa_translation_predictors_translation_id FOREIGN KEY (translation_id) REFERENCES taxa.translations(translation_id) ON DELETE CASCADE,
    CONSTRAINT fk_taxa_translation_predictors_predictor_id FOREIGN KEY (predictor_id) REFERENCES geo.predictors(predictor_id)
);

/******************************************************************************************************************
 SAMPLE SCHEMA
 */

CREATE SCHEMA sample;
GRANT USAGE ON SCHEMA sample TO PUBLIC;

CREATE TABLE sample.sample_methods (
    sample_method_id    SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    sample_method_name  VARCHAR(50) UNIQUE NOT NULL,
    is_active           BOOLEAN NOT NULL DEFAULT TRUE,
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE TRIGGER tr_sample_methods_update BEFORE UPDATE ON sample.sample_methods FOR EACH ROW EXECUTE PROCEDURE fn_before_update();


CREATE TABLE sample.sample_types (
    sample_type_id      SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    sample_type_name    VARCHAR(50) UNIQUE NOT NULL,
    is_active           BOOLEAN NOT NULL DEFAULT TRUE,
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE TRIGGER tr_sample_types BEFORE UPDATE ON sample.sample_types FOR EACH ROW EXECUTE PROCEDURE fn_before_update();


CREATE TABLE sample.box_states (
    box_state_id        SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    box_state_name      VARCHAR(50) UNIQUE NOT NULL,
    box_state_order     SMALLINT UNIQUE NOT NULL,
    description         TEXT,
    is_active           BOOLEAN NOT NULL DEFAULT TRUE,

    CONSTRAINT chk_box_states CHECK (box_state_order > 0)
);

CREATE TABLE sample.project_types (
    project_type_id     SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    project_type_name   VARCHAR(255) UNIQUE NOT NULL,
    description         TEXT,
    is_active           BOOLEAN NOT NULL DEFAULT TRUE
);

CREATE TABLE sample.projects (
    project_id          SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    project_name        VARCHAR(255) UNIQUE NOT NULL,
    project_type_id     SMALLINT NOT NULL,
    is_private          BOOLEAN DEFAULT TRUE,
    contact_id          SMALLINT,
    extent              GEOMETRY(MultiPolygon, 4326),
    auto_update_samples BOOLEAN NOT NULL DEFAULT FALSE,
    description         TEXT,
    metadata            JSON,
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_projects_contact_id FOREIGN KEY (contact_id) REFERENCES entity.entities(entity_id),
    CONSTRAINT fk_projects_project_type_id FOREIGN KEY (project_type_id) REFERENCES sample.project_types(project_type_id)
);
CREATE INDEX fx_projects_contact_id ON sample.projects(contact_id);
CREATE INDEX fx_projects_project_type_id ON sample.projects(project_type_id);
CREATE INDEX gx_projects_extent ON sample.projects USING GIST(extent);
CREATE TRIGGER tr_projects_update BEFORE UPDATE ON sample.projects FOR EACH ROW EXECUTE PROCEDURE fn_before_update();


-- TODO: table design incomplete
-- TODO: review columns copied from PilotDB.BugTacking
-- TODO: UsuTrack changed from FLOAT to SMALLINT
-- TODO: hook up billing_cust_id to customers? Confirm purpose
-- TODO: Default icost and tcost to zero?
-- TODO:
CREATE TABLE sample.boxes (
    box_id                      INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    customer_id                 SMALLINT NOT NULL,
    submitter_id                SMALLINT NOT NULL,
    box_state_id                SMALLINT NOT NULL,
    box_recevied_date           TIMESTAMPTZ, -- date the box arrives
    processing_complete_date    TIMESTAMPTZ, -- date lab processing is complete
    projected_complete_date     TIMESTAMPTZ, -- report_ready, available to customer, customer notified. all data QAed.
--     report_out          TIMESTAMPTZ, -- drop this column. use completed_date instead.
    sort_time           FLOAT, -- drop. Should be summation
    id_time             FLOAT, -- drop. should be summation
    description         TEXT,
    metadata            JSON,
    project_id          SMALLINT, -- changing this ID through the UI will need to change the sample_projects junction table
    measurements        BOOLEAN NOT NULL DEFAULT FALSE, -- things customers can be billed for (fee per sample) checkbox in submission UI
    sorter_qa           BOOLEAN NOT NULL DEFAULT FALSE, -- things customers can be billed for (fee per sample) checkbox in submission UI
    taxa_qa             BOOLEAN NOT NULL DEFAULT FALSE, -- things customers can be billed for (fee per sample) checkbox in submission UI
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_boxes_customer_id FOREIGN KEY (customer_id) REFERENCES entity.entities(entity_id),
    CONSTRAINT fk_boxes_creator_id FOREIGN KEY (submitter_id) REFERENCES entity.individuals(individual_id),
    CONSTRAINT fk_boxes_state_id FOREIGN KEY (box_state_id) REFERENCES sample.box_states(box_state_id),
    CONSTRAINT fk_boxes_project_id FOREIGN KEY (project_id) REFERENCES sample.projects(project_id)
);
CREATE INDEX fx_boxes_customer_id ON sample.boxes(customer_id);
CREATE INDEX fx_boxes_status_id ON sample.boxes(box_state_id);
CREATE INDEX fx_boxes_project_id ON sample.boxes(project_id);
CREATE TRIGGER tr_boxes_update BEFORE UPDATE ON sample.boxes FOR EACH ROW EXECUTE PROCEDURE fn_before_update();


CREATE TABLE sample.billing (
    billing_id          SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    box_id              INT NOT NULL,
    overhead            FLOAT, -- move to billing - meant to be the amount of time non tax or sort (labeling, QA)
    porder              VARCHAR(255), -- move to billing tables
    icost               FLOAT, -- move to billing tables
    tcost               SMALLINT, -- go into billing table
    billing_customer_id SMALLINT, -- goes into the billing tables

    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_billing_box_id FOREIGN KEY (box_id) REFERENCES sample.boxes(box_id)
);
CREATE INDEX fx_billing_box_id ON sample.billing(box_id);

-- TODO: do we need a similar "sample_submission_data" table?
CREATE TABLE sample.box_submission_data (
    box_id              INT NOT NULL PRIMARY KEY,
    metadata            JSONB NOT NULL,

    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_box_submission_data FOREIGN KEY (box_id) REFERENCES sample.boxes(box_id) ON DELETE CASCADE
);
CREATE TRIGGER tr_sumbission_data_update BEFORE UPDATE ON sample.box_submission_data FOR EACH ROW EXECUTE PROCEDURE fn_before_update();


-- TODO: Verify that it's OK to make qualitative NOT NULL and check what the default should be
-- TODO: verify that Count field is not needed?
-- TODO: verify that SorterChironomidae is needed?
-- TODO: what is the field PilotDB.BugSample.MainID?
-- TODO: what is the field PilotDB.BugSample.LabID?
-- TODO: what is the field PilotDB.BugSample.Replicates?
-- TODO: what is the field PilotDB.BugSample.Archive?
-- TODO: I have converted mesh FROM FLOAT to SMALLINT. OK? Values are 56, 120, 180, 425
-- Jar count is the initial number of jars that the customer sends for each sample
CREATE TABLE sample.samples (
    sample_id           INT GENERATED BY DEFAULT AS IDENTITY,
    box_id              INT NOT NULL,
    site_id             INT,
    sample_date         DATE,
    sample_time         TIME,
    type_id             SMALLINT NOT NULL,
    method_id           SMALLINT NOT NULL,
    habitat_id          SMALLINT NOT NULL,
    area                REAL,
    field_split         REAL,
    field_notes         TEXT,
    lab_split           REAL,
    jar_count           SMALLINT NOT NULL DEFAULT 1,
    qualitative         BOOLEAN DEFAULT FALSE,
    lab_notes           TEXT,
    mesh                SMALLINT,
    sorter_count        SMALLINT,
    sorter_id           SMALLINT,
    sort_time           REAL NOT NULL DEFAULT 0,
    sort_start_date     TIMESTAMPTZ,
    sort_end_date       TIMESTAMPTZ,
    ider_id             SMALLINT,
    id_time             REAL NOT NULL DEFAULT 0,
    id_start_date       TIMESTAMPTZ,
    id_end_date         TIMESTAMPTZ,
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    qa_sample_id        SMALLINT,
    lab_id              SMALLINT,
    metadata            JSON,

    CONSTRAINT pk_samples PRIMARY KEY (sample_id),
    CONSTRAINT fk_samples_box_id FOREIGN KEY (box_id) REFERENCES sample.boxes(box_id) ON DELETE CASCADE,
    CONSTRAINT fk_samples_site_id FOREIGN KEY (site_id) REFERENCES geo.sites(site_id),
    CONSTRAINT fk_samples_type_id FOREIGN KEY (type_id) REFERENCES sample.sample_types(sample_type_id),
    CONSTRAINT fk_samples_method_id FOREIGN KEY (method_id) REFERENCES sample.sample_methods(sample_method_id),
    CONSTRAINT fk_samples_habitat_id FOREIGN KEY (habitat_id) REFERENCES geo.habitats(habitat_id),
    CONSTRAINT fk_samples_sorter_id FOREIGN KEY (sorter_id) REFERENCES entity.individuals(individual_id),
    CONSTRAINT fk_samples_ider_id FOREIGN KEY (ider_id) REFERENCES entity.individuals(individual_id),
    CONSTRAINT fk_samples_lab_id FOREIGN KEY (lab_id) REFERENCES entity.organizations(organization_id),
    CONSTRAINT ck_samples_area CHECK (area >= 0),
    CONSTRAINT ck_samples_field_split CHECK (field_split >= 0),
    CONSTRAINT ck_samples_lab_split CHECK (lab_split >= 0),
    CONSTRAINT chk_samples_sorter_count CHECK (sorter_count >= 0),
    CONSTRAINT chk_samples_mesh CHECK (mesh > 0),
    CONSTRAINT chk_samples_jar_count CHECK (jar_count > 0)
);
CREATE INDEX fx_samples_box_id ON sample.samples(box_id);
CREATE INDEX fx_samples_site_id ON sample.samples(site_id);
CREATE INDEX fx_samples_type_id ON sample.samples(type_id);
CREATE INDEX fx_samples_method_id ON sample.samples(method_id);
CREATE INDEX fx_samples_habitat_id ON sample.samples(habitat_id);
CREATE INDEX fx_samples_lab_id ON sample.samples(lab_id);
CREATE TRIGGER tr_samples_update BEFORE UPDATE ON sample.samples FOR EACH ROW EXECUTE PROCEDURE fn_before_update();


CREATE TYPE TOW_TYPES AS ENUM ('Vertical', 'Horizontal');

CREATE TABLE sample.sample_labs (
    sample_id           INT NOT NULL,
    organization_id     SMALLINT NOT NULL,
    lab_type_id         SMALLINT NOT NULL,

    CONSTRAINT pk_sample_labs PRIMARY KEY (sample_id, organization_id, lab_type_id),
    CONSTRAINT fk_sample_labs_sample_id FOREIGN KEY (sample_id) REFERENCES sample.samples(sample_id) ON DELETE CASCADE,
    CONSTRAINT fk_sample_labs_entity_id FOREIGN KEY (organization_id) REFERENCES entity.organizations(organization_id),
    CONSTRAINT fk_sample_labs_lab_type_id FOREIGN KEY (lab_type_id) REFERENCES entity.lab_types(lab_type_id)
);

-- TODO: move fields from sample.samples to this table
CREATE TABLE sample.benthic (
    sample_id           INT NOT NULL PRIMARY KEY,
    notes               TEXT,
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_sample_benthic_sample_id FOREIGN KEY (sample_id) REFERENCES sample.samples(sample_id) ON DELETE CASCADE
);
CREATE TRIGGER tr_benthic_update BEFORE UPDATE ON sample.benthic FOR EACH ROW EXECUTE PROCEDURE fn_before_update();


CREATE TABLE sample.plankton (
    sample_id           INT NOT NULL PRIMARY KEY,
    diameter            REAL,
    sub_sample_count    SMALLINT,
    tow_length          REAL,
    volume              REAL,
    all_quot            REAL,
    size_interval       REAL,
    tow_type            TOW_TYPES,
    notes               TEXT,
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_plankton_sample_id FOREIGN KEY (sample_id) REFERENCES sample.samples(sample_id) ON DELETE CASCADE,
    CONSTRAINT ck_plankton_diameter CHECK (diameter > 0),
    CONSTRAINT ck_plankton_sub_sample_count CHECK (sub_sample_count >= 0),
    CONSTRAINT ck_plankton_tow_length CHECK (tow_length > 0),
    CONSTRAINT ck_plankton_volume CHECK (volume > 0),
    CONSTRAINT ck_plankton_size_interval CHECK (size_interval > 0)
);
CREATE TRIGGER tr_plankton_update BEFORE UPDATE ON sample.plankton FOR EACH ROW EXECUTE PROCEDURE fn_before_update();


-- TODO: confirm that velo means velocity
CREATE TABLE sample.drift (
    sample_id           INT NOT NULL PRIMARY KEY,
    net_area            FLOAT,
    net_duration        FLOAT,
    stream_depth        FLOAT,
    net_depth           FLOAT,
    net_velo            FLOAT,
    notes               TEXT,
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT ck_bug_drift_net_area CHECK (net_area > 0),
    CONSTRAINT ck_bug_drift_net_duration CHECK (net_duration > 0),
    CONSTRAINT ck_bug_drift_stream_depth CHECK (stream_depth > 0),
    CONSTRAINT ck_bug_drift_net_depth CHECK (net_depth > 0),
    CONSTRAINT ck_bug_drift_net_velo CHECK (net_velo >= 0)
);
CREATE TRIGGER tr_drift_update BEFORE UPDATE ON sample.drift FOR EACH ROW EXECUTE PROCEDURE fn_before_update();

CREATE TABLE sample.mass_methods (
    mass_method_id      SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    mass_method_name    VARCHAR(255) UNIQUE NOT NULL,
    abbreviation        VARCHAR(15) UNIQUE NOT NULL,
    is_active           BOOLEAN NOT NULL DEFAULT TRUE
);

CREATE TABLE sample.mass_types (
    mass_type_id        SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    mass_type_name      VARCHAR(255) UNIQUE NOT NULL,
    abbreviation        VARCHAR(15) UNIQUE NOT NULL,
    is_active           BOOLEAN NOT NULL DEFAULT TRUE
);

/*
 AFDM = Ash free dry mass
 The old bug o matter table used to have AFDM column. IT was a sum of several
 different kinds of mass.
 */
CREATE TABLE sample.mass (
    sample_id           INT NOT NULL,
    mass_type_id        SMALLINT NOT NULL,
    mass_method_id      SMALLINT NOT NULL,
    mass                REAL NOT NULL,
    notes               TEXT,
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT pk_mass PRIMARY KEY (sample_id, mass_type_id),
    CONSTRAINT fk_mass_sample_id FOREIGN KEY (sample_id) REFERENCES sample.samples(sample_id) ON DELETE CASCADE,
    CONSTRAINT fk_mass_mass_type_id FOREIGN KEY (mass_type_id) REFERENCES sample.mass_types(mass_type_id),
    CONSTRAINT fk_mass_method_id FOREIGN KEY (mass_method_id) REFERENCES sample.mass_methods(mass_method_id)
);
CREATE INDEX fx_mass_type_id ON sample.mass(mass_type_id);
CREATE INDEX fx_mass_method_id ON sample.mass(mass_method_id);
CREATE TRIGGER tr_mass_update BEFORE UPDATE ON sample.mass FOR EACH ROW EXECUTE PROCEDURE fn_before_update();


-- TODO PilotDB.Stomachs.Code is NULL and the species column has species as text
CREATE TABLE sample.fish (
    sample_id           INT NOT NULL PRIMARY KEY,
    taxonomy_id         SMALLINT NOT NULL,
    fish_length         REAL,
    fish_mass           REAL,
    notes               TEXT,
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_fish_sample_id FOREIGN KEY (sample_id) REFERENCES sample.samples(sample_id) ON DELETE CASCADE,
    CONSTRAINT fk_fish_taxonomy_id FOREIGN KEY (taxonomy_id) REFERENCES taxa.taxonomy(taxonomy_id),
    CONSTRAINT ck_fish_fish_length CHECK (fish_length >= 0),
    CONSTRAINT ck_fish_fish_mass CHECK (fish_mass >= 0)
);
CREATE INDEX fish_taxa_id ON sample.fish(taxonomy_id);
CREATE TRIGGER tr_fish_update BEFORE UPDATE ON sample.fish FOR EACH ROW EXECUTE PROCEDURE fn_before_update();


CREATE TABLE sample.sort_qa (
    sample_id           INT NOT NULL PRIMARY KEY,
    sorter2_id          SMALLINT NOT NULL,
    sorted_date         TIMESTAMPTZ NOT NULL,
    bugs_resorted       SMALLINT NOT NULL,
    sorter_efficiency   REAL,
    elutriation         BOOLEAN NOT NULL,
    split               REAL,
    sort_time           REAL,
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_sample_sort_qa_sorter2_id FOREIGN KEY (sorter2_id) REFERENCES entity.individuals(individual_id),
    CONSTRAINT ck_sample_sort_qa_bugs_resorted CHECK (bugs_resorted >= 0),
    CONSTRAINT ck_sample_sort_qa_sorter_efficiency CHECK ((sorter_efficiency >= 0) AND (sorter_efficiency <= 100)),
    CONSTRAINT ck_sample_qaqc_qaqc_split CHECK ((split >=0) AND (split <= 100)),
    CONSTRAINT ck_sample_qaqc_sort_time CHECK ((sort_time>=0) AND (sort_time < 24))
);
CREATE TRIGGER tr_sort_qa_update BEFORE UPDATE ON sample.sort_qa FOR EACH ROW EXECUTE PROCEDURE fn_before_update();


-- TODO: maybe could be descriptive text instead? 'BEFORE RECONCILIATION' and 'AFTER RECONCILIATION'
CREATE TYPE QA_STAGES AS ENUM ('Before Reconciliation', 'After Reconciliation');

-- TODO: old table has OTUCode. What should this be now?
-- TODO: taxa_qa data type and reference?
-- TODO: should ider1 and ider2 be NOT NULL?
-- TODO: should ptd_class, bray_curtis_class and pde_class be boolean, enum or lookup?
-- TODO: constraints on the numerical fields
CREATE TABLE sample.taxa_qa (
    sample_id           INT NOT NULL PRIMARY KEY,
    taxa_qa             SMALLINT,
    taxa_qa_stage       QA_STAGES,
    start_date          TIMESTAMPTZ NOT NULL DEFAULT now(),
    ider1               SMALLINT NOT NULL,
    ider2               SMALLINT,
    sorter_count_diff   SMALLINT,
    taxa_count_diff     SMALLINT,
    code_count          SMALLINT,
    bray_curtis         REAL,
    bray_curtis_class   BOOLEAN,
    ptd                 REAL,
    ptd_class           BOOLEAN,
    pde                 REAL,
    pde_class           BOOLEAN,
    ptc1                REAL,
    ptc2                REAL,
    notes               TEXT,
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_sample_taxa_qa_ider1 FOREIGN KEY (ider1) REFERENCES entity.individuals(individual_id),
    CONSTRAINT fk_sample_taxa_qa_ider2 FOREIGN KEY (ider2) REFERENCES entity.individuals(individual_id)
);
CREATE INDEX fx_sample_taxa_qa_ider1 ON sample.taxa_qa(ider1);
CREATE INDEX fx_sample_taxa_qa_ider2 ON sample.taxa_qa(ider2);
CREATE TRIGGER tr_taxa_qa_update BEFORE UPDATE ON sample.taxa_qa FOR EACH ROW EXECUTE PROCEDURE fn_before_update();


/*
 The Valid column is not currently used. But its there to invalidate
 a certain row, and then ignore it from all the subsequent processes.

 Currently delete the data if it is not valid. This was done infrequently
 as part of large QA efforts across big datasets.

 Experiment with using a date for invalidating a record. This can
 then reveal in a report whether the metrics predate a record
 getting eliminated.
 */
CREATE TABLE sample.organisms (
    organism_id         INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    sample_id           INT NOT NULL,
    taxonomy_id         SMALLINT NOT NULL,
    life_stage_id       SMALLINT NOT NULL,
    bug_size            REAL,
    split_count         REAL,
    big_rare_count      SMALLINT,
    invalidated_date    TIMESTAMPTZ,
    notes               TEXT,
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_organisms_sample_id FOREIGN KEY (sample_id) REFERENCES sample.samples(sample_id) ON DELETE CASCADE,
    CONSTRAINT fk_organisms_taxonomy_id FOREIGN KEY (taxonomy_id) REFERENCES taxa.taxonomy(taxonomy_id),
    CONSTRAINT fk_organisms_life_stage_id FOREIGN KEY (life_stage_id) REFERENCES taxa.life_stages(life_stage_id)
);
-- TODO: Comment out temporarily while waiting for information from David.
-- CREATE UNIQUE INDEX ux_organism_organisms ON sample.organisms(sample_id, taxonomy_id, life_stage_id, bug_size);
CREATE TRIGGER tr_organisms_update BEFORE UPDATE ON sample.organisms FOR EACH ROW EXECUTE PROCEDURE fn_before_update();



CREATE TABLE sample.note_types (
    note_id             SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    note_name           VARCHAR(25) UNIQUE NOT NULL,
    abbreviation        CHAR(1) UNIQUE NOT NULL,
    description         TEXT,
    is_active           BOOLEAN NOT NULL DEFAULT TRUE,

    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE TRIGGER tr_note_types_update BEFORE UPDATE ON sample.note_types FOR EACH ROW EXECUTE PROCEDURE fn_before_update();


CREATE TABLE sample.organism_notes (
    organism_id         INT NOT NULL,
    note_id             SMALLINT NOT NULL,

    CONSTRAINT pk_organism_types PRIMARY KEY (organism_id, note_id),
    CONSTRAINT fk_organism_types_organism_id FOREIGN KEY (organism_id) REFERENCES sample.organisms(organism_id) ON DELETE CASCADE,
    CONSTRAINT fk_organism_types_note_id FOREIGN KEY (note_id) REFERENCES sample.note_types(note_id)
);

-- TODO: would this table be better named as sample.asset_types
CREATE TABLE sample.assets (
    asset_id            SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    asset_name          VARCHAR(255) NOT NULL UNIQUE,
    description         TEXT,

    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE TRIGGER tr_assets_update BEFORE UPDATE ON sample.assets FOR EACH ROW EXECUTE PROCEDURE fn_before_update();


CREATE TABLE sample.sample_assets (
    sample_id           INT NOT NULL,
    asset_id            INT NOT NULL,

    CONSTRAINT pk_sample_assets PRIMARY KEY (sample_id, asset_id),
    CONSTRAINT fk_sample_assets_sample_id FOREIGN KEY (sample_id) REFERENCES sample.samples(sample_id) ON DELETE CASCADE,
    CONSTRAINT fk_sample_assets_asset_id FOREIGN KEY (asset_id) REFERENCES sample.assets(asset_id)
);

CREATE TABLE sample.sample_predictors (
    sample_id           INT NOT NULL,
    predictor_id        SMALLINT NOT NULL,
    location            GEOMETRY(Point, 4326) NOT NULL,
    catchment           GEOMETRY(MultiPolygon, 4326) NOT NULL,
    metadata            JSONB,
    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE INDEX gx_sites_location ON sample.sample_predictors USING GIST(location);
CREATE INDEX gx_sites_catchment ON sample.sample_predictors USING GIST(catchment);
CREATE TRIGGER tr_sample_predictors_update BEFORE UPDATE ON sample.sample_predictors FOR EACH ROW EXECUTE PROCEDURE fn_before_update();


CREATE TABLE sample.project_samples (
    project_id          SMALLINT NOT NULL,
    sample_id           INT NOT NULL,

    CONSTRAINT pk_project_samples PRIMARY KEY (project_id, sample_id),
    CONSTRAINT fk_projct_samples_sample_id FOREIGN KEY (sample_id) REFERENCES sample.samples(sample_id) ON DELETE CASCADE,
    CONSTRAINT fk_project_samples_project_id FOREIGN KEY (project_id) REFERENCES sample.projects(project_id) ON DELETE CASCADE
);

/******************************************************************************************************************
 METRIC SCHEMA
 */

CREATE SCHEMA metric;
GRANT USAGE ON SCHEMA metric TO PUBLIC;

CREATE TABLE metric.metric_types (
    metric_type_id      SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    metric_name         VARCHAR(255) UNIQUE NOT NULL,
    description         TEXT,
    unit_id             SMALLINT NOT NULL,

    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_metric_types_unit_id FOREIGN KEY (unit_id) REFERENCES geo.units(unit_id)
);
CREATE INDEX fx_metric_types_unit_id ON metric.metric_types(unit_id);
CREATE TRIGGER tr_metric_types_update BEFORE UPDATE ON metric.metric_types FOR EACH ROW EXECUTE PROCEDURE fn_before_update();


CREATE TABLE metric.metrics (
    metric_id           INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    sample_id           INT NOT NULL,
    metric_type_id      SMALLINT NOT NULL,
    translation_id      SMALLINT NOT NULL,

    CONSTRAINT fk_metrics_sample_id FOREIGN KEY (sample_id) REFERENCES sample.samples(sample_id) ON DELETE CASCADE,
    CONSTRAINT fk_metrics_metric_type_id FOREIGN KEY (metric_type_id) REFERENCES metric.metric_types(metric_type_id),
    CONSTRAINT fk_metrics_translation_id FOREIGN KEY (translation_id) REFERENCES taxa.translations(translation_id) ON DELETE CASCADE
);
CREATE INDEX fx_metrics_metric_type_id ON metric.metrics(metric_type_id);
CREATE TRIGGER tr_metrics_update BEFORE UPDATE ON metric.metrics FOR EACH ROW EXECUTE PROCEDURE fn_before_update();


CREATE TABLE metric.reports (
    report_id           SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    report_name         VARCHAR(255) UNIQUE NOT NULL,
    description         TEXT,
    is_active           BOOLEAN NOT NULL DEFAULT TRUE,

    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE TRIGGER tr_reports_update BEFORE UPDATE ON metric.reports FOR EACH ROW EXECUTE PROCEDURE fn_before_update();


CREATE TABLE metric.analysis_types (
    analysis_type_id    SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    analysis_type_name  VARCHAR(255) UNIQUE NOT NULL,
    report_id           SMALLINT NOT NULL,

    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_analysis_types_report_id FOREIGN KEY (report_id) REFERENCES metric.reports(report_id) ON DELETE CASCADE
);
CREATE INDEX fx_analysis_types_report_id ON metric.analysis_types(report_id);
CREATE TRIGGER tr_analysis_types_update BEFORE UPDATE ON metric.analysis_types FOR EACH ROW EXECUTE PROCEDURE fn_before_update();


CREATE TABLE metric.analyses (
    analysis_id      INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    analysis_type_id SMALLINT NOT NULL,

    created_date     TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date     TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_analyses_analysis_type_id FOREIGN KEY (analysis_id) REFERENCES metric.analysis_types (analysis_type_id)
);
CREATE TRIGGER tr_analyses_update BEFORE UPDATE ON metric.analyses FOR EACH ROW EXECUTE PROCEDURE fn_before_update();

/******************************************************************************************************************
 BILLING SCHEMA
 */

CREATE SCHEMA billing;
GRANT USAGE ON SCHEMA billing TO PUBLIC;


CREATE TABLE billing.line_item_types (
    line_item_type_id   SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    line_item_type_name VARCHAR(255) UNIQUE NOT NULL,
    is_active           BOOLEAN NOT NULL DEFAULT TRUE,

    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE billing.agreement_types (
    agreement_type_id   SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    agreement_type_name VARCHAR(255) UNIQUE NOT NULL,
    description         TEXT,
    is_active           BOOLEAN NOT NULL DEFAULT TRUE,

    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now()
);


CREATE TABLE billing.agreements (
    agreement_id        SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    entity_id           SMALLINT NOT NULL,
    agreement_type_id   SMALLINT NOT NULL,
    a_number            VARCHAR(20),
    start_date          DATE,
    end_date            DATE,
    is_editable         BOOLEAN NOT NULL DEFAULT TRUE,

    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_agreements_entity_id FOREIGN KEY (entity_id) REFERENCES entity.entities(entity_id),
    CONSTRAINT fk_agreements_agreement_type_id FOREIGN KEY (agreement_type_id) REFERENCES billing.agreement_types(agreement_type_id)
);
CREATE INDEX fx_agreements_entity_id ON billing.agreements(entity_id);
CREATE INDEX fx_agreements_agreement_type_id ON billing.agreements(agreement_type_id);

CREATE TABLE billing.agreement_items (
    agreement_item_id   INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    agreement_id        SMALLINT NOT NULL,
    line_item_type_id   SMALLINT NOT NULL,
    units               SMALLINT NOT NULL DEFAULT 0,
    unit_cost           INT NOT NULL DEFAULT 0,
    description         TEXT,

    CONSTRAINT fk_agreement_items_agreement_id FOREIGN KEY (agreement_id) REFERENCES billing.agreements(agreement_id),
    CONSTRAINT fk_agreement_items_line_item_type_id FOREIGN KEY (line_item_type_id) REFERENCES billing.line_item_types(line_item_type_id),
    CONSTRAINT ck_agreement_items_units CHECK (units >= 0),
    CONSTRAINT ck_agreement_items_unit_cost CHECK (unit_cost >= 0)
);
CREATE UNIQUE INDEX fx_agreement_items_agreement_id ON billing.agreement_items(agreement_id, line_item_type_id);

CREATE TABLE billing.invoices (
    invoice_id          SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    entity_id           SMALLINT NOT NULL,
    agreement_id        SMALLINT,
    invoice_date        DATE NOT NULL,
    due_date            DATE NOT NULL,
    invoice_number      SMALLINT UNIQUE NOT NULL,

    created_date        TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_date        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fk_invoices_entity_id FOREIGN KEY (entity_id) REFERENCES entity.entities(entity_id),
    CONSTRAINT fk_invoices_agreement_id FOREIGN KEY (agreement_id) REFERENCES billing.agreements(agreement_id)
);
CREATE INDEX fx_invoices_entity_id ON billing.invoices(entity_id);
CREATE INDEX fx_invoices_agreement_id ON billing.invoices(agreement_id);

CREATE TABLE billing.invoice_items (
    invoice_item_id     INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    invoice_id          SMALLINT NOT NULL,
    line_item_type_id   SMALLINT NOT NULL,
    units               SMALLINT NOT NULL DEFAULT 0,
    unit_price          INT NOT NULL DEFAULT 0,

    CONSTRAINT fk_invoice_items_invoice_id FOREIGN KEY (invoice_id) REFERENCES billing.invoices(invoice_id),
    CONSTRAINT fk_invoice_items_line_item_type_id FOREIGN KEY (line_item_type_id) REFERENCES billing.line_item_types(line_item_type_id),
    CONSTRAINT ck_invoice_items_units CHECK (units >= 0),
    CONSTRAINT ck_invoice_items_unit_price CHECK (unit_price >= 0)
);
CREATE INDEX fx_invoice_items_invoice_id ON billing.invoice_items(invoice_id);
CREATE INDEX fx_invoice_items_line_item_type_id ON billing.invoice_items(line_item_type_id);

CREATE TABLE billing.invoice_boxes (
    invoice_id          SMALLINT NOT NULL,
    box_id              SMALLINT NOT NULL,

    CONSTRAINT pk_invoice_boxes PRIMARY KEY (invoice_id, box_id),
    CONSTRAINT fk_invoice_boxes_invoice_id FOREIGN KEY (invoice_id) REFERENCES billing.invoices(invoice_id),
    CONSTRAINT fk_invoice_boxes_box_id FOREIGN KEY (box_id) REFERENCES sample.boxes(box_id)
);