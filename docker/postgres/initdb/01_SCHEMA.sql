CREATE EXTENSION postgis;
CREATE EXTENSION tablefunc;


CREATE FUNCTION fnBeforeUpdate()
RETURNS trigger AS
    $$
    BEGIN
        NEW.UpdatedDate = now();
        RETURN NEW;
    END ;
$$
LANGUAGE 'plpgsql';

-- /******************************************************************************************************************
--  Metadata SCHEMA
--  */
--
--  CREATE SCHEMA Metadata;
--  GRANT USAGE ON SCHEMA Metadata TO PUBLIC;
--
--  CREATE TABLE Metadata.data_dictionary (
--
--  );

/******************************************************************************************************************
 GEO SCHEMA
 */

CREATE SCHEMA Geo;
GRANT USAGE ON SCHEMA Geo TO PUBLIC;

CREATE TABLE Geo.Countries (
    CountryID           SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    CountryName         VARCHAR(50) UNIQUE NOT NULL,
    Abbreviation        VARCHAR(5) NOT NULL,
    Geometry            Geometry(MultiPolygon, 4326),
    CreatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),
    UpdatedDate         TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE INDEX gxCountriesGeometry ON Geo.Countries USING GIST(Geometry);
CREATE TRIGGER trCountriesUpdate BEFORE UPDATE ON Geo.Countries FOR EACH ROW EXECUTE PROCEDURE fnBeforeUpdate();

CREATE TABLE Geo.States (
    StateID             SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    CountryID           SMALLINT NOT NULL,
    StateName           VARCHAR(50) NOT NULL,
    Abbreviation        VARCHAR(2) NOT NULL,
    Geometry            Geometry(MultiPolygon, 4326),
    CreatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),
    UpdatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fkStatesCountryID FOREIGN KEY (CountryID) REFERENCES Geo.Countries(CountryID)
);
CREATE INDEX ixStatesCountryID ON Geo.States(CountryID);
CREATE UNIQUE INDEX uxStatesName ON Geo.States(CountryID, StateName);
CREATE UNIQUE INDEX uxStatesAbbreviation ON Geo.States(CountryID, Abbreviation);
CREATE INDEX gxStatesGeometry ON Geo.States USING GIST(Geometry);
CREATE TRIGGER trStatesUpdate BEFORE UPDATE ON Geo.States FOR EACH ROW EXECUTE PROCEDURE fnBeforeUpdate();


CREATE TABLE Geo.Counties (
    CountyID            SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    StateID             SMALLINT NOT NULL,
    CountyName          VARCHAR(255) NOT NULL,
    Geometry            Geometry(MultiPolygon, 4326),
    CreatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),
    UpdatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fkCountiesStateID FOREIGN KEY (StateID) REFERENCES Geo.States(StateID)
);
CREATE INDEX ixCountiesStateID ON Geo.Counties(StateID);
CREATE UNIQUE INDEX uxCountiesName ON Geo.Counties(StateID, CountyName);
CREATE INDEX gxCountiesGeometry ON Geo.Counties USING GIST(Geometry);
CREATE TRIGGER trCountiesUpdate BEFORE UPDATE ON Geo.Counties FOR EACH ROW EXECUTE PROCEDURE fnBeforeUpdate();


CREATE TABLE Geo.LandUses (
    LandUseID           SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    LandUseName         VARCHAR(50) UNIQUE NOT NULL,
    IsActive            BOOLEAN NOT NULL DEFAULT TRUE,
    CreatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),
    UpdatedDate         TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE TRIGGER trLandUsesUpdate BEFORE UPDATE ON Geo.LandUses FOR EACH ROW EXECUTE PROCEDURE fnBeforeUpdate();


CREATE TABLE Geo.Ecosystems (
    EcosystemID         SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    EcosystemName       VARCHAR(10) UNIQUE NOT NULL,
    IsActive            BOOLEAN NOT NULL DEFAULT TRUE,
    Description         TEXT,
    CreatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),
    UpdatedDate         TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE TRIGGER trEcosystemsUpdate BEFORE UPDATE ON Geo.Ecosystems FOR EACH ROW EXECUTE PROCEDURE fnBeforeUpdate();


CREATE TABLE Geo.Habitats (
    HabitatID           SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    HabitatName         VARCHAR(50) UNIQUE NOT NULL,
    EcosystemID         SMALLINT NOT NULL,
    IsActive            BOOLEAN NOT NULL DEFAULT TRUE,
    CreatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),
    UpdatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fkHabitatsEcosystemID FOREIGN KEY (EcosystemID) REFERENCES Geo.Ecosystems(EcosystemID)
);
CREATE INDEX ixHabitatsEcosystemID ON Geo.Habitats(EcosystemID);
CREATE TRIGGER trHabitatsUpdate BEFORE UPDATE ON Geo.Habitats FOR EACH ROW EXECUTE PROCEDURE fnBeforeUpdate();


CREATE TABLE Geo.Units (
    UnitID              SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    UnitName            VARCHAR(50) UNIQUE NOT NULL,
    Abbreviation        VARCHAR(10) UNIQUE NOT NULL,
    Description         TEXT,
    CreatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),
    UpdatedDate         TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE TRIGGER trUnitsUpdate BEFORE UPDATE ON Geo.Units FOR EACH ROW EXECUTE PROCEDURE fnBeforeUpdate();


CREATE TABLE Geo.Systems (
    SystemID            SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    SystemName          VARCHAR(20) UNIQUE NOT NULL,
    EcosystemID         SMALLINT NOT NULL,
    IsActive            BOOLEAN NOT NULL DEFAULT TRUE,
    CreatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),
    UpdatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fkSystemsEcosystemID FOREIGN KEY (EcosystemID) REFERENCES Geo.Ecosystems(EcosystemID)
);
CREATE INDEX ixSystemsEcosystemID ON Geo.Systems(EcosystemID);
CREATE TRIGGER trSystemsUpdate BEFORE UPDATE ON Geo.Systems FOR EACH ROW EXECUTE PROCEDURE fnBeforeUpdate();


-- TODO: table design incomplete
CREATE TABLE Geo.Sites (
    SiteID              INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    SiteName            VARCHAR(50) UNIQUE NOT NULL,
    SystemID            SMALLINT,
    EcosystemID         SMALLINT,
    Description         TEXT,
    Waterbody           VARCHAR(255),
    Location            Geometry(Point, 4326) NOT NULL,
    Catchment           Geometry(MultiPolygon, 4326),
    NHDPlusID           BIGINT,
    COMID               BIGINT,
    Metadata            JSON,
    CreatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),
    UpdatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fkSitesSystemID FOREIGN KEY (SystemID) REFERENCES Geo.Systems(SystemID),
    CONSTRAINT fkSitesEcosystemID FOREIGN KEY (EcosystemID) REFERENCES Geo.Ecosystems(EcosystemID)
);
CREATE INDEX gxSitesLocation ON Geo.Sites USING GIST(location);
CREATE INDEX gxSitesCatchment ON Geo.Sites USING GIST(catchment);
CREATE INDEX fxSitesSystems ON Geo.Sites(SystemID);
CREATE INDEX fxSitesEcosystems ON Geo.Sites(EcosystemID);
CREATE TRIGGER trSitesUpdate BEFORE UPDATE ON Geo.Sites FOR EACH ROW EXECUTE PROCEDURE fnBeforeUpdate();


CREATE TABLE Geo.PredictorTypes (
    PredictorTypeID     SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    PredictorTypeName   VARCHAR(255) UNIQUE NOT NULL,
    CreatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),
    UpdatedDate         TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE TRIGGER trPredictorTypesUpdate BEFORE UPDATE ON Geo.PredictorTypes FOR EACH ROW EXECUTE PROCEDURE fnBeforeUpdate();


CREATE TABLE Geo.Predictors (
    PredictorID         SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    PredictorName       VARCHAR(255) UNIQUE NOT NULL,
    Abbreviation        VARCHAR(25) UNIQUE NOT NULL,
    UnitID              SMALLINT NOT NULL,
    PredictorTypeID     SMALLINT NOT NULL,
    Description         TEXT,
    Metadata            JSON,
    CreatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),
    UpdatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fkPredictorsUnitID FOREIGN KEY (UnitID) REFERENCES Geo.Units(UnitID),
    CONSTRAINT fkPredictorsPredictorTypeID FOREIGN KEY (PredictorTypeID) REFERENCES Geo.PredictorTypes(PredictorTypeID)
);
CREATE INDEX fxPredictorsUnitID ON Geo.Predictors(UnitID);
CREATE INDEX fkPredictorsPredictorTypeID ON Geo.Predictors(PredictorTypeID);
CREATE TRIGGER trPredictorsUpdate BEFORE UPDATE ON Geo.Predictors FOR EACH ROW EXECUTE PROCEDURE fnBeforeUpdate();


CREATE TABLE Geo.SitePredictors (
    PredictorID         SMALLINT NOT NULL,
    SiteID              INT NOT NULL,
    Metadata            JSONB NOT NULL,
    CreatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),
    UpdatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT pkSitePredictors PRIMARY KEY (PredictorID, SiteID),
    CONSTRAINT fkSitePredictors FOREIGN KEY (PredictorID) REFERENCES Geo.Predictors(PredictorID),
    CONSTRAINT fkSiteSiteID FOREIGN KEY (SiteID) REFERENCES Geo.Sites(SiteID)
);
CREATE TRIGGER trSitePredictorsUpdate BEFORE UPDATE ON Geo.SitePredictors FOR EACH ROW EXECUTE PROCEDURE fnBeforeUpdate();


/******************************************************************************************************************
 ENTITY SCHEMA
 */

CREATE SCHEMA Entity;
GRANT USAGE ON SCHEMA Entity TO PUBLIC;
-- ALTER DEFAULT PRIVILEGES IN SCHEMA entity GRANT ALL ON TABLES TO PUBLIC;

CREATE TABLE Entity.Entities (
    EntityID            SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    ParentID            SMALLINT,
    Address1            VARCHAR(255),
    Address2            VARCHAR(255),
    City                VARCHAR(255),
    StateID             SMALLINT,
    CountryID           SMALLINT NOT NULL,
    ZipCode             VARCHAR(20),
    Phone               VARCHAR(50),
    Fax                 VARCHAR(50),
    WebSite             VARCHAR(255),
    Notes               TEXT,
    Metadata            JSON,
    CreatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),
    UpdatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fkEntitiesParentID FOREIGN KEY (ParentID) REFERENCES Entity.Entities(EntityID),
    CONSTRAINT fkEntitiesStateID FOREIGN KEY (StateID) REFERENCES Geo.States(StateID),
    CONSTRAINT fkEntitiesCountryID FOREIGN KEY (CountryID) REFERENCES Geo.Countries(CountryID)
);
CREATE INDEX fxEntitiesStateID ON Entity.Entities(StateID);
CREATE INDEX fxEntitiesCountryID ON Entity.Entities(CountryID);
CREATE TRIGGER trEntitiesUpdate BEFORE UPDATE ON Entity.Entities FOR EACH ROW EXECUTE PROCEDURE fnBeforeUpdate();


CREATE TABLE Entity.OrganizationTypes (
    OrganizationTypeID      SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    OrganizationTypeName    VARCHAR(50) UNIQUE NOT NULL
);

CREATE TABLE Entity.Organizations (
    OrganizationID          SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    Abbreviation            VARCHAR(50),
    OrganizationName        VARCHAR(255),
    EntityID                SMALLINT NOT NULL,
    OrganizationTypeID      SMALLINT NOT NULL,
    IsLab                   BOOLEAN NOT NULL DEFAULT FALSE,

    CONSTRAINT fkOrganizationsEntityID FOREIGN KEY (EntityID) REFERENCES Entity.Entities(EntityID) ON DELETE CASCADE,
    CONSTRAINT fkOrganizationsOrganizationTypeID FOREIGN KEY (OrganizationTypeID) REFERENCES Entity.OrganizationTypes(OrganizationTypeID)
);
CREATE UNIQUE INDEX uxOrganizationsEntityID ON Entity.Organizations(EntityID);
CREATE INDEX fxOrganizationsOrganizationTypeID ON Entity.Organizations(OrganizationTypeID);

-- TODO: table design incomplete. Need to implement roles here.
-- TODO: do we really need gender and other non-bug identification information
CREATE TABLE Entity.Individuals (
    IndividualID        SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    FistName            VARCHAR(50) NOT NULL,
    LastName            VARCHAR(50) NOT NULL,
    Initials            VARCHAR(3),
    EntityID            SMALLINT NOT NULL,
    AffiliationID       SMALLINT,
    Email               VARCHAR(255),
    Title               VARCHAR(255),

    CONSTRAINT fkIndividualsEntityID FOREIGN KEY (EntityID) REFERENCES Entity.Entities(EntityID) ON DELETE CASCADE,
    CONSTRAINT fkIndividualsAffiliationID FOREIGN KEY (AffiliationID) REFERENCES Entity.Organizations(OrganizationID)
);
CREATE UNIQUE INDEX uxIndividualsEntityID ON Entity.Individuals(EntityID);
CREATE INDEX fxIndividualsAffiliationID ON Entity.Individuals(AffiliationID);

CREATE TABLE Entity.Roles (
    RoleID              SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    RoleName            VARCHAR(255) UNIQUE NOT NULL,
    Description         TEXT
);

CREATE TABLE Entity.IndividualRoles (
    IndividualID        SMALLINT NOT NULL,
    RoleID              SMALLINT NOT NULL,

    CONSTRAINT pkIndividualsRoles PRIMARY KEY (IndividualID, roleID),
    CONSTRAINT fkIndividualRolesIndividualID FOREIGN KEY (IndividualID) REFERENCES Entity.Individuals(IndividualID) ON DELETE CASCADE,
    CONSTRAINT fkIndividualRolesRoleID FOREIGN KEY (RoleID) REFERENCES Entity.Roles(RoleID)
);

CREATE TABLE Entity.LabTypes (
    LabTypeID           SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    LabTypeName         VARCHAR(255) UNIQUE NOT NULL
);

/******************************************************************************************************************
 ORGANISM SCHEMA
 */

CREATE SCHEMA Taxa;
GRANT USAGE ON SCHEMA Taxa TO PUBLIC;

CREATE TABLE Taxa.TaxaLevels(
    LevelID             SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    levelName          VARCHAR(50) UNIQUE NOT NULL,
    ParentLevelID       SMALLINT UNIQUE,
    IsActive            BOOLEAN NOT NULL DEFAULT TRUE,
    Description         TEXT,

    CONSTRAINT fkTaxaLevelsParentLevelID FOREIGN KEY (ParentLevelID) REFERENCES Taxa.TaxaLevels(LevelID)
);

CREATE TABLE Taxa.LifeStages (
    LifeStageID         SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    Abbreviation        CHAR(1) UNIQUE NOT NULL,
    LifeStageName       VARCHAR(50) UNIQUE NOT NULL,
    IsActive            BOOLEAN NOT NULL DEFAULT TRUE
);

CREATE TABLE Taxa.Taxonomy (
    TaxonomyID          SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    ScientificName      VARCHAR(255) NOT NULL,
    LevelID             SMALLINT NOT NULL,
    ParentID            SMALLINT,
    Author              VARCHAR(255),
    Year                SMALLINT,
    CreatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),
    UpdatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fkOrganismTaxonomyTaxaLevelID FOREIGN KEY (LevelID) REFERENCES Taxa.TaxaLevels(LevelID)
);
CREATE INDEX fxOrganismTaxonomyTaxaLevelID ON Taxa.Taxonomy(LevelID);
CREATE TRIGGER trTaxonomyUpdate BEFORE UPDATE ON Taxa.Taxonomy FOR EACH ROW EXECUTE PROCEDURE fnBeforeUpdate();


CREATE TABLE Taxa.Synonyms (
    SynonymID           SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    TaxonomyID          SMALLINT NOT NULL,
    Synonym             VARCHAR(255) NOT NULL,

    CONSTRAINT fkSynonymsTaxonomyID FOREIGN KEY (TaxonomyID) REFERENCES Taxa.Taxonomy(TaxonomyID) ON DELETE CASCADE
);
CREATE INDEX fxSynonymsTaxonomyID ON Taxa.Synonyms(TaxonomyID);

CREATE TYPE ATTRIBUTE_TYPES AS ENUM ('Float', 'Integer', 'Text', 'Unknown');


CREATE TABLE Taxa.Attributes (
    AttributeID         SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    AttributeName       VARCHAR(255) UNIQUE NOT NULL,
    AttributeType       ATTRIBUTE_TYPES NOT NULL,
    Label               VARCHAR(255),
    Description         TEXT,
    Metadata            JSON,

    CreatedDate        TIMESTAMPTZ NOT NULL DEFAULT now(),
    UpdatedDate        TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE TRIGGER trAttributesUpdate BEFORE UPDATE ON taxa.attributes FOR EACH ROW EXECUTE PROCEDURE fnBeforeUpdate();


CREATE TABLE Taxa.TaxaAttributes (
    TaxonomyID         SMALLINT NOT NULL,
    AttributeID        SMALLINT NOT NULL,
    AttributeValue     VARCHAR(100) NOT NULL,

    CONSTRAINT pkTaxaAttributes PRIMARY KEY (TaxonomyID, AttributeID),
    CONSTRAINT fkTaxaAttributesTaxonomyID FOREIGN KEY (TaxonomyID) REFERENCES Taxa.Taxonomy(TaxonomyID) ON DELETE CASCADE,
    CONSTRAINT fkTaxaAttributesAttributeID FOREIGN KEY (AttributeID) REFERENCES Taxa.Attributes(AttributeID)
);

/*
 ITIS
 Encyc of Life
 Wiki Species
 */
CREATE TABLE Taxa.ExternalSources (
    SourceID            SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    SourceName          VARCHAR(255) UNIQUE NOT NULL,
    Abbreviation        VARCHAR(10) UNIQUE NOT NULL,
    Description         TEXT,
    Metadata            JSONB
);

/*
 TSN is the ITIS primary key

 ITIS calls synonyms valid or invalid for up to date or older name.
 */
CREATE TABLE Taxa.ExternalIDs (
--     externalID         SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

    SourceID            SMALLINT NOT NULL,
    TaxonomyID          SMALLINT NOT NULL,
    ExternalSourceID    VARCHAR(255),
    ScientificName      VARCHAR(255),

    CONSTRAINT pkExternalIDs PRIMARY KEY (SourceID, TaxonomyID),
    CONSTRAINT fkExternalIDsSourceID FOREIGN KEY (SourceID) REFERENCES Taxa.ExternalSources(SourceID) ON DELETE CASCADE,
    CONSTRAINT fkExternalIDsTaxonomyID FOREIGN KEY (TaxonomyID) REFERENCES Taxa.Taxonomy(TaxonomyID)
);

CREATE TABLE Taxa.Translations (
    TranslationID       SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    TranslationName     VARCHAR(255) UNIQUE NOT NULL,
    Description         TEXT,
    IsActive            BOOLEAN NOT NULL DEFAULT TRUE,

    CreatedDate        TIMESTAMPTZ NOT NULL DEFAULT now(),
    UpdatedDate        TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE TRIGGER trTranslationsUpdate BEFORE UPDATE ON Taxa.Translations FOR EACH ROW EXECUTE PROCEDURE fnBeforeUpdate();


CREATE TABLE Taxa.TaxaTranslations (
    TranslationID           SMALLINT NOT NULL,
    TaxonomyID              SMALLINT NOT NULL,
    TranslationTaxonomyID   SMALLINT NOT NULL,

    CONSTRAINT pkTaxaTranslations PRIMARY KEY (TranslationID, TaxonomyID),
    CONSTRAINT fkTaxaTranslationsTranslationID FOREIGN KEY (TranslationID) REFERENCES Taxa.Translations(TranslationID) ON DELETE CASCADE,
    CONSTRAINT fkTaxaTranslationsTaxonomyID FOREIGN KEY (TaxonomyID) REFERENCES taxa.taxonomy(TaxonomyID),
    CONSTRAINT fkTaxaTranslationsTranslationTaxonomyID FOREIGN KEY (TranslationTaxonomyID) REFERENCES Taxa.Taxonomy(TaxonomyID)
);
CREATE INDEX fxTaxaTranslationsTaxonomyID ON Taxa.TaxaTranslations(TaxonomyID);
CREATE INDEX fxTaxaTranslationsTranslationTaxonomyID ON Taxa.TaxaTranslations(TranslationTaxonomyID);

CREATE TABLE Taxa.TranslationPredictors (
    TranslationID           SMALLINT NOT NULL,
    PredictorID             SMALLINT NOT NULL,

    CONSTRAINT pkTaxaTranslationPredictors PRIMARY KEY (TranslationID, PredictorID),
    CONSTRAINT fkTaxaTranslationPredictorsTranslationID FOREIGN KEY (TranslationID) REFERENCES Taxa.Translations(TranslationID) ON DELETE CASCADE,
    CONSTRAINT fkTaxaTranslationPredictorsPredictorID FOREIGN KEY (PredictorID) REFERENCES Geo.Predictors(PredictorID)
);

/******************************************************************************************************************
 SAMPLE SCHEMA
 */

CREATE SCHEMA Sample;
GRANT USAGE ON SCHEMA Sample TO PUBLIC;

CREATE TABLE Sample.SampleMethods (
    SampleMethodID      SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    SampleMethodName    VARCHAR(50) UNIQUE NOT NULL,
    IsActive            BOOLEAN NOT NULL DEFAULT TRUE,
    CreatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),
    UpdatedDate         TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE TRIGGER trSampleMethodsUpdate BEFORE UPDATE ON Sample.SampleMethods FOR EACH ROW EXECUTE PROCEDURE fnBeforeUpdate();


CREATE TABLE Sample.SampleTypes (
    SampleTypeID        SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    SampleTypeName      VARCHAR(50) UNIQUE NOT NULL,
    IsActive            BOOLEAN NOT NULL DEFAULT TRUE,
    CreatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),
    UpdatedDate         TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE TRIGGER trSampleTypes BEFORE UPDATE ON Sample.SampleTypes FOR EACH ROW EXECUTE PROCEDURE fnBeforeUpdate();


CREATE TABLE Sample.BoxStates (
    BoxStateID          SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    BoxStateName        VARCHAR(50) UNIQUE NOT NULL,
    BoxStateOrder       SMALLINT UNIQUE NOT NULL,
    Description         TEXT,
    IsActive            BOOLEAN NOT NULL DEFAULT TRUE,

    CONSTRAINT chkBoxStates CHECK (BoxStateOrder > 0)
);

CREATE TABLE Sample.ProjectTypes (
    ProjectTypeID       SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    ProjectTypeName     VARCHAR(255) UNIQUE NOT NULL,
    Description         TEXT,
    IsActive            BOOLEAN NOT NULL DEFAULT TRUE
);

CREATE TABLE Sample.Projects (
    ProjectID           SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    ProjectName         VARCHAR(255) UNIQUE NOT NULL,
    ProjectTypeID       SMALLINT NOT NULL,
    IsPrivate           BOOLEAN DEFAULT TRUE,
    ContactID           SMALLINT,
    Extent              Geometry(MultiPolygon, 4326),
    AutoUpdateSamples   BOOLEAN NOT NULL DEFAULT FALSE,
    Description         TEXT,
    Metadata            JSON,
    CreatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),
    UpdatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fkProjectsContactID FOREIGN KEY (ContactID) REFERENCES Entity.Entities(EntityID),
    CONSTRAINT fkProjectsProjectTypeID FOREIGN KEY (ProjectTypeID) REFERENCES Sample.ProjectTypes(ProjectTypeID)
);
CREATE INDEX fxProjectsContactID ON Sample.Projects(ContactID);
CREATE INDEX fxProjectsProjectTypeID ON Sample.Projects(ProjectTypeID);
CREATE INDEX gxProjectsExtent ON Sample.projects USING GIST(Extent);
CREATE TRIGGER trProjectsUpdate BEFORE UPDATE ON Sample.Projects FOR EACH ROW EXECUTE PROCEDURE fnBeforeUpdate();


-- TODO: table design incomplete
-- TODO: review columns copied from PilotDB.BugTacking
-- TODO: UsuTrack changed from FLOAT to SMALLINT
-- TODO: hook up billing_custID to customers? Confirm purpose
-- TODO: Default icost and tcost to zero?
-- TODO:
CREATE TABLE Sample.Boxes (
    BoxID                   INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    CustomerID              SMALLINT NOT NULL,
    SubmitterID             SMALLINT NOT NULL,
    BoxStateID              SMALLINT NOT NULL,
    BoxReceviedDate         TIMESTAMPTZ, -- date the box arrives
    ProcessingCompleteDate  TIMESTAMPTZ, -- date lab processing is complete
    ProjectedCompleteDate   TIMESTAMPTZ, -- report_ready, available to customer, customer notified. all data QAed.
--     report_out          TIMESTAMPTZ, -- drop this column. use completed_date instead.
    -- SortTime           FLOAT, -- drop. Should be summation
    -- id_time             FLOAT, -- drop. should be summation
    Description             TEXT,
    Metadata                JSON,
    ProjectID               SMALLINT, -- changing this ID through the UI will need to change the sample_projects junction table
    Measurements            BOOLEAN NOT NULL DEFAULT FALSE, -- things customers can be billed for (fee per sample) checkbox in submission UI
    SorterQA                BOOLEAN NOT NULL DEFAULT FALSE, -- things customers can be billed for (fee per sample) checkbox in submission UI
    TaxaQA                  BOOLEAN NOT NULL DEFAULT FALSE, -- things customers can be billed for (fee per sample) checkbox in submission UI
    CreatedDate             TIMESTAMPTZ NOT NULL DEFAULT now(),
    UpdatedDate             TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fkBoxesCustomerID FOREIGN KEY (CustomerID) REFERENCES Entity.Entities(EntityID),
    CONSTRAINT fkBoxesCreatorID FOREIGN KEY (SubmitterID) REFERENCES Entity.Individuals(IndividualID),
    CONSTRAINT fkBoxesStateID FOREIGN KEY (BoxStateID) REFERENCES Sample.BoxStates(BoxStateID),
    CONSTRAINT fkBoxesProjectID FOREIGN KEY (ProjectID) REFERENCES Sample.Projects(ProjectID)
);
CREATE INDEX fxBoxesCustomerID ON Sample.boxes(CustomerID);
CREATE INDEX fxBoxesStatusID ON Sample.boxes(BoxStateID);
CREATE INDEX fxBoxesProjectID ON Sample.boxes(ProjectID);
CREATE TRIGGER trBoxesUpdate BEFORE UPDATE ON Sample.Boxes FOR EACH ROW EXECUTE PROCEDURE fnBeforeUpdate();


CREATE TABLE Sample.Billing (
    BillingID           SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    BoxID               INT NOT NULL,
    Overhead            FLOAT, -- move to billing - meant to be the amount of time non tax or sort (labeling, QA)
    POrder              VARCHAR(255), -- move to billing tables
    ICost               FLOAT, -- move to billing tables
    TCost               SMALLINT, -- go into billing table
    BillingCustomerID   SMALLINT, -- goes into the billing tables

    CreatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),
    UpdatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fkBillingBoxID FOREIGN KEY (BoxID) REFERENCES Sample.boxes(BoxID)
);
CREATE INDEX fxBillingBoxID ON Sample.billing(BoxID);

-- TODO: do we need a similar "sample_submission_data" table?
CREATE TABLE Sample.BoxSubmissionData (
    BoxID               INT NOT NULL PRIMARY KEY,
    Metadata            JSONB NOT NULL,

    CreatedDate        TIMESTAMPTZ NOT NULL DEFAULT now(),
    UpdatedDate        TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fkBoxSubmissionData FOREIGN KEY (BoxID) REFERENCES Sample.Boxes(BoxID) ON DELETE CASCADE
);
CREATE TRIGGER trSumbissionDataUpdate BEFORE UPDATE ON Sample.BoxSubmissionData FOR EACH ROW EXECUTE PROCEDURE fnBeforeUpdate();


-- TODO: Verify that it's OK to make qualitative NOT NULL and check what the default should be
-- TODO: verify that Count field is not needed?
-- TODO: verify that SorterChironomidae is needed?
-- TODO: what is the field PilotDB.BugSample.MainID?
-- TODO: what is the field PilotDB.BugSample.LabID?
-- TODO: what is the field PilotDB.BugSample.Replicates?
-- TODO: what is the field PilotDB.BugSample.Archive?
-- TODO: I have converted mesh FROM FLOAT to SMALLINT. OK? Values are 56, 120, 180, 425
-- Jar count is the initial number of jars that the customer sends for each sample
CREATE TABLE Sample.Samples (
    SampleID            INT GENERATED BY DEFAULT AS IDENTITY,
    BoxID               INT NOT NULL,
    SiteID              INT,
    SampleDate          DATE,
    SampleTime          TIME,
    TypeID              SMALLINT NOT NULL,
    MethodID            SMALLINT NOT NULL,
    HabitatID           SMALLINT NOT NULL,
    Area                REAL,
    FieldSplit          REAL,
    FieldNotes          TEXT,
    LabSplit            REAL,
    JarCount            SMALLINT NOT NULL DEFAULT 1,
    Qualitative         BOOLEAN DEFAULT FALSE,
    LabNotes            TEXT,
    Mesh                SMALLINT,
    SorterCount         SMALLINT,
    SorterID            SMALLINT,
    SortTime            REAL NOT NULL DEFAULT 0,
    SortStartDate       TIMESTAMPTZ,
    SortEndDate         TIMESTAMPTZ,
    IDerID              SMALLINT,
    IDTime              REAL NOT NULL DEFAULT 0,
    IDStartDate         TIMESTAMPTZ,
    IDEndDate           TIMESTAMPTZ,
    CreatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),
    UpdatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),
    QASampleID          SMALLINT,
    LabID               SMALLINT,
    Metadata            JSON,

    CONSTRAINT pkSamples PRIMARY KEY (SampleID),
    CONSTRAINT fkSamplesBoxID FOREIGN KEY (BoxID) REFERENCES Sample.Boxes(BoxID) ON DELETE CASCADE,
    CONSTRAINT fkSamplesSiteID FOREIGN KEY (SiteID) REFERENCES Geo.Sites(SiteID),
    CONSTRAINT fkSamplesTypeID FOREIGN KEY (typeID) REFERENCES Sample.SampleTypes(SampleTypeID),
    CONSTRAINT fkSamplesMethodID FOREIGN KEY (methodID) REFERENCES Sample.SampleMethods(SampleMethodID),
    CONSTRAINT fkSamplesHabitatID FOREIGN KEY (HabitatID) REFERENCES Geo.Habitats(HabitatID),
    CONSTRAINT fkSamplesSorterID FOREIGN KEY (sorterID) REFERENCES Entity.Individuals(IndividualID),
    CONSTRAINT fkSamplesIDerID FOREIGN KEY (iderID) REFERENCES Entity.Individuals(IndividualID),
    CONSTRAINT fkSamplesLabID FOREIGN KEY (labID) REFERENCES Entity.Organizations(OrganizationID),
    CONSTRAINT ckSamplesArea CHECK (Area >= 0),
    CONSTRAINT ckSamplesFieldSplit CHECK (FieldSplit >= 0),
    CONSTRAINT ckSamplesLabSplit CHECK (LabSplit >= 0),
    CONSTRAINT chkSamplesSorterCount CHECK (SorterCount >= 0),
    CONSTRAINT chkSamplesMesh CHECK (Mesh > 0),
    CONSTRAINT chkSamplesJarCount CHECK (JarCount > 0)
);
CREATE INDEX fxSamplesBoxID ON Sample.Samples(BoxID);
CREATE INDEX fxSamplesSiteID ON Sample.Samples(SiteID);
CREATE INDEX fxSamplesTypeID ON Sample.Samples(typeID);
CREATE INDEX fxSamplesMethodID ON Sample.Samples(methodID);
CREATE INDEX fxSamplesHabitatID ON Sample.Samples(HabitatID);
CREATE INDEX fxSamplesLabID ON Sample.Samples(labID);
CREATE TRIGGER trSamplesUpdate BEFORE UPDATE ON Sample.Samples FOR EACH ROW EXECUTE PROCEDURE fnBeforeUpdate();


CREATE TYPE TOW_TYPES AS ENUM ('Vertical', 'Horizontal');

CREATE TABLE Sample.SampleLabs (
    SampleID            INT NOT NULL,
    OrganizationID      SMALLINT NOT NULL,
    LabTypeID           SMALLINT NOT NULL,

    CONSTRAINT pkSampleLabs PRIMARY KEY (SampleID, OrganizationID, LabTypeID),
    CONSTRAINT fkSampleLabsSampleID FOREIGN KEY (SampleID) REFERENCES Sample.Samples(SampleID) ON DELETE CASCADE,
    CONSTRAINT fkSampleLabsEntityID FOREIGN KEY (OrganizationID) REFERENCES Entity.Organizations(OrganizationID),
    CONSTRAINT fkSampleLabsLabTypeID FOREIGN KEY (LabTypeID) REFERENCES Entity.LabTypes(LabTypeID)
);

-- TODO: move fields from Sample.Samples to this table
CREATE TABLE Sample.Benthic (
    SampleID            INT NOT NULL PRIMARY KEY,
    Notes               TEXT,
    UpdatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fkSampleBenthicSampleID FOREIGN KEY (SampleID) REFERENCES Sample.Samples(SampleID) ON DELETE CASCADE
);
CREATE TRIGGER trBenthicUpdate BEFORE UPDATE ON Sample.Benthic FOR EACH ROW EXECUTE PROCEDURE fnBeforeUpdate();


CREATE TABLE Sample.Plankton (
    SampleID            INT NOT NULL PRIMARY KEY,
    Diameter            REAL,
    SubSampleCount      SMALLINT,
    TowLength           REAL,
    Volume              REAL,
    AllQuot             REAL,
    SizeInterval        REAL,
    TowType             TOW_TYPES,
    Notes               TEXT,
    UpdatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fkPlanktonSampleID FOREIGN KEY (SampleID) REFERENCES Sample.Samples(SampleID) ON DELETE CASCADE,
    CONSTRAINT ckPlanktonDiameter CHECK (Diameter > 0),
    CONSTRAINT ckPlanktonSubSampleCount CHECK (SubSampleCount >= 0),
    CONSTRAINT ckPlanktonTowLength CHECK (TowLength > 0),
    CONSTRAINT ckPlanktonVolume CHECK (Volume > 0),
    CONSTRAINT ckPlanktonSizeInterval CHECK (SizeInterval > 0)
);
CREATE TRIGGER trPlanktonUpdate BEFORE UPDATE ON Sample.Plankton FOR EACH ROW EXECUTE PROCEDURE fnBeforeUpdate();


-- TODO: confirm that velo means velocity
CREATE TABLE Sample.drift (
    SampleID            INT NOT NULL PRIMARY KEY,
    NetArea             FLOAT,
    NetDuration         FLOAT,
    StreamDepth         FLOAT,
    NetDepth            FLOAT,
    NetVelo             FLOAT,
    Notes               TEXT,
    UpdatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT ckBugDriftNetArea CHECK (NetArea > 0),
    CONSTRAINT ckBugDriftNetDuration CHECK (NetDuration > 0),
    CONSTRAINT ckBugDriftStreamDepth CHECK (StreamDepth > 0),
    CONSTRAINT ckBugDriftNetDepth CHECK (NetDepth > 0),
    CONSTRAINT ckBugDriftNetVelo CHECK (NetVelo >= 0)
);
CREATE TRIGGER trDriftUpdate BEFORE UPDATE ON Sample.Drift FOR EACH ROW EXECUTE PROCEDURE fnBeforeUpdate();

CREATE TABLE Sample.MassMethods (
    MassMethodID        SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    MassMethodName      VARCHAR(255) UNIQUE NOT NULL,
    Abbreviation        VARCHAR(15) UNIQUE NOT NULL,
    IsActive            BOOLEAN NOT NULL DEFAULT TRUE
);

CREATE TABLE Sample.MassTypes (
    MassTypeID          SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    MassTypeName        VARCHAR(255) UNIQUE NOT NULL,
    Abbreviation        VARCHAR(15) UNIQUE NOT NULL,
    IsActive            BOOLEAN NOT NULL DEFAULT TRUE
);

/*
 AFDM = Ash free dry mass
 The old bug o matter table used to have AFDM column. IT was a sum of several
 different kinds of mass.
 */
CREATE TABLE Sample.Mass (
    SampleID            INT NOT NULL,
    MassTypeID          SMALLINT NOT NULL,
    MassMethodID        SMALLINT NOT NULL,
    Mass                REAL NOT NULL,
    Notes               TEXT,
    UpdatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT pkMass PRIMARY KEY (SampleID, MassTypeID),
    CONSTRAINT fkMassSampleID FOREIGN KEY (SampleID) REFERENCES Sample.Samples(SampleID) ON DELETE CASCADE,
    CONSTRAINT fkMassMassTypeID FOREIGN KEY (massTypeID) REFERENCES Sample.MassTypes(MassTypeID),
    CONSTRAINT fkMassMethodID FOREIGN KEY (massMethodID) REFERENCES Sample.MassMethods(MassMethodID)
);
CREATE INDEX fxMassTypeID ON Sample.mass(MassTypeID);
CREATE INDEX fxMassMethodID ON Sample.mass(MassMethodID);
CREATE TRIGGER trMassUpdate BEFORE UPDATE ON Sample.mass FOR EACH ROW EXECUTE PROCEDURE fnBeforeUpdate();


-- TODO PilotDB.Stomachs.Code is NULL and the species column has species as text
CREATE TABLE Sample.Fish (
    SampleID            INT NOT NULL PRIMARY KEY,
    TaxonomyID          SMALLINT NOT NULL,
    FishLength          REAL,
    FishMass            REAL,
    Notes               TEXT,
    UpdatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fkFishSampleID FOREIGN KEY (SampleID) REFERENCES Sample.Samples(SampleID) ON DELETE CASCADE,
    CONSTRAINT fkFishTaxonomyID FOREIGN KEY (TaxonomyID) REFERENCES taxa.taxonomy(TaxonomyID),
    CONSTRAINT ckFishFishLength CHECK (FishLength >= 0),
    CONSTRAINT ckFishFishMass CHECK (FishMass >= 0)
);
CREATE INDEX fxFishTaxonomyID ON Sample.Fish(TaxonomyID);
CREATE TRIGGER trFishUpdate BEFORE UPDATE ON Sample.Fish FOR EACH ROW EXECUTE PROCEDURE fnBeforeUpdate();


CREATE TABLE Sample.SortQA (
    SampleID            INT NOT NULL PRIMARY KEY,
    Sorter2ID           SMALLINT NOT NULL,
    SortedDate          TIMESTAMPTZ NOT NULL,
    BugsResorted        SMALLINT NOT NULL,
    SorterEfficiency    REAL,
    Elutriation         BOOLEAN NOT NULL,
    Split               REAL,
    SortTime            REAL,
    CreatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),
    UpdatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fkSampleSortQASorter2ID FOREIGN KEY (Sorter2ID) REFERENCES Entity.Individuals(IndividualID),
    CONSTRAINT ckSampleSortQABugsResorted CHECK (BugsResorted >= 0),
    CONSTRAINT ckSampleSortQASorterEfficiency CHECK ((SorterEfficiency >= 0) AND (SorterEfficiency <= 100)),
    CONSTRAINT ckSampleSportSplit CHECK ((split >=0) AND (Split <= 100)),
    CONSTRAINT ckSampleQAQCSortTime CHECK ((SortTime>=0) AND (SortTime < 24))
);
CREATE TRIGGER trSortQAUpdate BEFORE UPDATE ON Sample.SortQA FOR EACH ROW EXECUTE PROCEDURE fnBeforeUpdate();


-- TODO: maybe could be descriptive text instead? 'BEFORE RECONCILIATION' and 'AFTER RECONCILIATION'
CREATE TYPE QA_STAGES AS ENUM ('Before Reconciliation', 'After Reconciliation');

-- TODO: old table has OTUCode. What should this be now?
-- TODO: TaxaQA data type and reference?
-- TODO: should ider1 and ider2 be NOT NULL?
-- TODO: should ptd_class, bray_curtis_class and pde_class be boolean, enum or lookup?
-- TODO: constraints on the numerical fields
CREATE TABLE Sample.TaxaQA (
    SampleID            INT NOT NULL PRIMARY KEY,
    TaxaQA              SMALLINT,
    TaxaQAStage         QA_STAGES,
    StartDate           TIMESTAMPTZ NOT NULL DEFAULT now(),
    IDer1               SMALLINT NOT NULL,
    IDer2               SMALLINT,
    SorterCountDiff     SMALLINT,
    TaxaCountDiff       SMALLINT,
    CodeCount           SMALLINT,
    BrayCurtis          REAL,
    BrayCurtisClass     BOOLEAN,
    PTD                 REAL,
    PTDClass            BOOLEAN,
    PDE                 REAL,
    pdeClass            BOOLEAN,
    PTC1                REAL,
    PTC2                REAL,
    Notes               TEXT,
    CreatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),
    UpdatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fkSampleTaxaQAIDer1 FOREIGN KEY (ider1) REFERENCES Entity.Individuals(IndividualID),
    CONSTRAINT fkSampleTaxaQAIDer2 FOREIGN KEY (ider2) REFERENCES Entity.Individuals(IndividualID)
);
CREATE INDEX fxSampleTaxaQAIDer1 ON Sample.TaxaQA(ider1);
CREATE INDEX fxSampleTaxaQAIDer2 ON Sample.TaxaQA(ider2);
CREATE TRIGGER trTaxaQAUpdate BEFORE UPDATE ON Sample.TaxaQA FOR EACH ROW EXECUTE PROCEDURE fnBeforeUpdate();


/*
 The Valid column is not currently used. But its there to invalidate
 a certain row, and then ignore it from all the subsequent processes.

 Currently delete the data if it is not valid. This was done infrequently
 as part of large QA efforts across big datasets.

 Experiment with using a date for invalidating a record. This can
 then reveal in a report whether the metrics predate a record
 getting eliminated.
 */
CREATE TABLE Sample.Organisms (
    organismID          INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    SampleID            INT NOT NULL,
    TaxonomyID          SMALLINT NOT NULL,
    LifeStageID        SMALLINT NOT NULL,
    BugSize             REAL,
    SplitCount          REAL,
    BigRareCount        SMALLINT,
    InvalidatedDate     TIMESTAMPTZ,
    Notes               TEXT,
    CreatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),
    UpdatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fkOrganismsSampleID FOREIGN KEY (SampleID) REFERENCES Sample.Samples(SampleID) ON DELETE CASCADE,
    CONSTRAINT fkOrganismsTaxonomyID FOREIGN KEY (TaxonomyID) REFERENCES Taxa.Taxonomy(TaxonomyID),
    CONSTRAINT fkOrganismsLifeStageID FOREIGN KEY (LifeStageID) REFERENCES Taxa.LifeStages(LifeStageID)
);
-- TODO: Comment out temporarily while waiting for information from David.
-- CREATE UNIQUE INDEX ux_organism_organisms ON Sample.organisms(SampleID, TaxonomyID, life_stageID, bug_size);
CREATE TRIGGER trOrganismsUpdate BEFORE UPDATE ON Sample.Organisms FOR EACH ROW EXECUTE PROCEDURE fnBeforeUpdate();


CREATE TABLE Sample.NoteTypes (
    NoteID              SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    NoteName            VARCHAR(25) UNIQUE NOT NULL,
    Abbreviation        CHAR(1) UNIQUE NOT NULL,
    Description         TEXT,
    IsActive            BOOLEAN NOT NULL DEFAULT TRUE,

    CreatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),
    UpdatedDate         TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE TRIGGER trNoteTypesUpdate BEFORE UPDATE ON Sample.NoteTypes FOR EACH ROW EXECUTE PROCEDURE fnBeforeUpdate();


CREATE TABLE Sample.OrganismNotes (
    OrganismID          INT NOT NULL,
    NoteID              SMALLINT NOT NULL,

    CONSTRAINT pkOrganismTypes PRIMARY KEY (OrganismID, NoteID),
    CONSTRAINT fkOrganismTypesOrganismID FOREIGN KEY (OrganismID) REFERENCES Sample.Organisms(OrganismID) ON DELETE CASCADE,
    CONSTRAINT fkOrganismTypesNoteID FOREIGN KEY (NoteID) REFERENCES Sample.NoteTypes(noteID)
);

-- TODO: would this table be better named as Sample.asset_types
CREATE TABLE Sample.Assets (
    AssetID             SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    AssetName           VARCHAR(255) NOT NULL UNIQUE,
    Description         TEXT,

    CreatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),
    UpdatedDate         TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE TRIGGER trAssetsUpdate BEFORE UPDATE ON Sample.Assets FOR EACH ROW EXECUTE PROCEDURE fnBeforeUpdate();


CREATE TABLE Sample.SampleAssets (
    SampleID            INT NOT NULL,
    AssetID             INT NOT NULL,

    CONSTRAINT pkSampleAssets PRIMARY KEY (SampleID, AssetID),
    CONSTRAINT fkSampleAssetsSampleID FOREIGN KEY (SampleID) REFERENCES Sample.Samples(SampleID) ON DELETE CASCADE,
    CONSTRAINT fkSampleAssetsAssetID FOREIGN KEY (AssetID) REFERENCES Sample.Assets(AssetID)
);

CREATE TABLE Sample.SamplePredictors (
    SampleID            INT NOT NULL,
    PredictorID         SMALLINT NOT NULL,
    Location            Geometry(Point, 4326) NOT NULL,
    Catchment           Geometry(MultiPolygon, 4326) NOT NULL,
    Metadata            JSONB,
    CreatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),
    UpdatedDate         TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE INDEX gxSitesLocation ON Sample.SamplePredictors USING GIST(Location);
CREATE INDEX gxSitesCatchment ON Sample.SamplePredictors USING GIST(Catchment);
CREATE TRIGGER trSamplePredictorsUpdate BEFORE UPDATE ON Sample.SamplePredictors FOR EACH ROW EXECUTE PROCEDURE fnBeforeUpdate();


CREATE TABLE Sample.ProjectSamples (
    ProjectID           SMALLINT NOT NULL,
    SampleID            INT NOT NULL,

    CONSTRAINT pkProjectSamples PRIMARY KEY (ProjectID, SampleID),
    CONSTRAINT fkProjctSamplesSampleID FOREIGN KEY (SampleID) REFERENCES Sample.Samples(SampleID) ON DELETE CASCADE,
    CONSTRAINT fkProjectSamplesProjectID FOREIGN KEY (ProjectID) REFERENCES Sample.Projects(ProjectID) ON DELETE CASCADE
);

/******************************************************************************************************************
 METRIC SCHEMA
 */

CREATE SCHEMA Metric;
GRANT USAGE ON SCHEMA Metric TO PUBLIC;

CREATE TABLE Metric.MetricTypes (
    MetricTypeID        SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    MetricName          VARCHAR(255) UNIQUE NOT NULL,
    Description         TEXT,
    UnitID              SMALLINT NOT NULL,

    CreatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),
    UpdatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fkMetricTypesUnitID FOREIGN KEY (UnitID) REFERENCES Geo.Units(UnitID)
);
CREATE INDEX fxMetricTypesUnitID ON Metric.MetricTypes(UnitID);
CREATE TRIGGER trMetricTypesUpdate BEFORE UPDATE ON Metric.MetricTypes FOR EACH ROW EXECUTE PROCEDURE fnBeforeUpdate();


CREATE TABLE Metric.Metrics (
    MetricID            INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    SampleID            INT NOT NULL,
    MetricTypeID        SMALLINT NOT NULL,
    TranslationID       SMALLINT NOT NULL,

    CONSTRAINT fkMetricsSampleID FOREIGN KEY (SampleID) REFERENCES Sample.Samples(SampleID) ON DELETE CASCADE,
    CONSTRAINT fkMetricsMetricTypeID FOREIGN KEY (MetricTypeID) REFERENCES Metric.MetricTypes(MetricTypeID),
    CONSTRAINT fkMetricsTranslationID FOREIGN KEY (TranslationID) REFERENCES Taxa.Translations(TranslationID) ON DELETE CASCADE
);
CREATE INDEX fxMetricsMetrictypeID ON Metric.Metrics(MetricTypeID);
CREATE TRIGGER trMetricsUpdate BEFORE UPDATE ON Metric.Metrics FOR EACH ROW EXECUTE PROCEDURE fnBeforeUpdate();


CREATE TABLE Metric.Reports (
    ReportID            SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    ReportName          VARCHAR(255) UNIQUE NOT NULL,
    Description         TEXT,
    IsActive            BOOLEAN NOT NULL DEFAULT TRUE,

    CreatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),
    UpdatedDate         TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE TRIGGER trReportsUpdate BEFORE UPDATE ON Metric.Reports FOR EACH ROW EXECUTE PROCEDURE fnBeforeUpdate();


CREATE TABLE Metric.AnalysisTypes (
    AnalysisTypeID      SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    AnalysisTypeName    VARCHAR(255) UNIQUE NOT NULL,
    ReportID            SMALLINT NOT NULL,

    CreatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),
    UpdatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fkAnalysisTypesReportID FOREIGN KEY (ReportID) REFERENCES Metric.Reports(ReportID) ON DELETE CASCADE
);
CREATE INDEX fxAnalysisTypesReportID ON Metric.AnalysisTypes(ReportID);
CREATE TRIGGER trAnalysisTypesUpdate BEFORE UPDATE ON Metric.AnalysisTypes FOR EACH ROW EXECUTE PROCEDURE fnBeforeUpdate();


CREATE TABLE Metric.Analyses (
    AnalysisID          INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    AnalysisTypeID      SMALLINT NOT NULL,

    CreatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),
    UpdatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fkAnalysesAnalysisTypeID FOREIGN KEY (AnalysisID) REFERENCES Metric.AnalysisTypes (AnalysisTypeID)
);
CREATE TRIGGER trAnalysesUpdate BEFORE UPDATE ON Metric.Analyses FOR EACH ROW EXECUTE PROCEDURE fnBeforeUpdate();

/******************************************************************************************************************
 BILLING SCHEMA
 */

CREATE SCHEMA Billing;
GRANT USAGE ON SCHEMA Billing TO PUBLIC;


CREATE TABLE Billing.LineItemTypes (
    LineItemTypeID      INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    LineItemTypeName    VARCHAR(255) UNIQUE NOT NULL,
    IsActive            BOOLEAN NOT NULL DEFAULT TRUE,

    CreatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),
    UpdatedDate         TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE billing.Quotes (
    QuoteID             SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    EntityID            SMALLINT NOT NULL,
    IsFixedPrice        BOOLEAN NOT NULL DEFAULT FALSE,
    Notes               VARCHAR(255),
    CreatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),
    UpdatedDate         TIMESTAMPTZ NOT NULL DEFAULT now(),

    CONSTRAINT fkQuotesEntityID FOREIGN KEY (EntityID) REFERENCES Entity.Entities(EntityID)
);
CREATE INDEX fxBillingQuotes ON Billing.Quotes(EntityID);

CREATE TABLE Billing.QuoteItems (
    QuoteID             SMALLINT NOT NULL,
    LineItemTypeID      SMALLINT NOT NULL,
    Quantity            SMALLINT NOT NULL,
    UnitPrice           REAL NOT NULL,

    CONSTRAINT pkBillingQuoteItems PRIMARY KEY (QuoteID, LineItemTypeID),
    CONSTRAINT fkQuoteItems FOREIGN KEY (QuoteID) REFERENCES Billing.Quotes(QuoteID),
    CONSTRAINT fkQuoteLineItemTypeID FOREIGN KEY (LineItemTypeID) REFERENCES Billing.LineItemTypes(LineItemTypeID),
    CONSTRAINT ckQuoteItemsQuantity CHECK (Quantity > 0),
    CONSTRAINT ckQuoteItemsUnitPrice CHECK (UnitPrice >= 0)
);

CREATE TABLE Billing.AgreementTypes (
  AgreementTypeID       SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  AgreementTypeName     VARCHAR(255) UNIQUE NOT NULL
);

CREATE TABLE Billing.Agreements (
    AgreementID         SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    EntityID            SMALLINT NOT NULL,
    AgreementTypeID     SMALLINT NOT NULL,
    StartDate           DATE,
    EndDate             DATE,

    CONSTRAINT fkAgreementsEntityID FOREIGN KEY (EntityID) REFERENCES Entity.Entities(EntityID),
    CONSTRAINT fkAgreementsAgreementTypeID FOREIGN KEY (AgreementTypeID) REFERENCES Billing.AgreementTypes(AgreementTypeID)
);